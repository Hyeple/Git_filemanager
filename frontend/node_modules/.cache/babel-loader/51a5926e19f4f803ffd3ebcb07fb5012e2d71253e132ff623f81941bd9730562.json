{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\nimport { isBigint, isDate, isInfinite, isMap, isNaNValue, isRegExp, isSet, isUndefined, isSymbol, isArray, isError, isTypedArray, isURL } from './is';\nimport { findArr } from './util';\nfunction simpleTransformation(isApplicable, annotation, transform, untransform) {\n  return {\n    isApplicable: isApplicable,\n    annotation: annotation,\n    transform: transform,\n    untransform: untransform\n  };\n}\nvar simpleRules = [simpleTransformation(isUndefined, 'undefined', function () {\n  return null;\n}, function () {\n  return undefined;\n}), simpleTransformation(isBigint, 'bigint', function (v) {\n  return v.toString();\n}, function (v) {\n  if (typeof BigInt !== 'undefined') {\n    return BigInt(v);\n  }\n  console.error('Please add a BigInt polyfill.');\n  return v;\n}), simpleTransformation(isDate, 'Date', function (v) {\n  return v.toISOString();\n}, function (v) {\n  return new Date(v);\n}), simpleTransformation(isError, 'Error', function (v, superJson) {\n  var baseError = {\n    name: v.name,\n    message: v.message\n  };\n  superJson.allowedErrorProps.forEach(function (prop) {\n    baseError[prop] = v[prop];\n  });\n  return baseError;\n}, function (v, superJson) {\n  var e = new Error(v.message);\n  e.name = v.name;\n  e.stack = v.stack;\n  superJson.allowedErrorProps.forEach(function (prop) {\n    e[prop] = v[prop];\n  });\n  return e;\n}), simpleTransformation(isRegExp, 'regexp', function (v) {\n  return '' + v;\n}, function (regex) {\n  var body = regex.slice(1, regex.lastIndexOf('/'));\n  var flags = regex.slice(regex.lastIndexOf('/') + 1);\n  return new RegExp(body, flags);\n}), simpleTransformation(isSet, 'set',\n// (sets only exist in es6+)\n// eslint-disable-next-line es5/no-es6-methods\nfunction (v) {\n  return __spreadArray([], __read(v.values()));\n}, function (v) {\n  return new Set(v);\n}), simpleTransformation(isMap, 'map', function (v) {\n  return __spreadArray([], __read(v.entries()));\n}, function (v) {\n  return new Map(v);\n}), simpleTransformation(function (v) {\n  return isNaNValue(v) || isInfinite(v);\n}, 'number', function (v) {\n  if (isNaNValue(v)) {\n    return 'NaN';\n  }\n  if (v > 0) {\n    return 'Infinity';\n  } else {\n    return '-Infinity';\n  }\n}, Number), simpleTransformation(function (v) {\n  return v === 0 && 1 / v === -Infinity;\n}, 'number', function () {\n  return '-0';\n}, Number), simpleTransformation(isURL, 'URL', function (v) {\n  return v.toString();\n}, function (v) {\n  return new URL(v);\n})];\nfunction compositeTransformation(isApplicable, annotation, transform, untransform) {\n  return {\n    isApplicable: isApplicable,\n    annotation: annotation,\n    transform: transform,\n    untransform: untransform\n  };\n}\nvar symbolRule = compositeTransformation(function (s, superJson) {\n  if (isSymbol(s)) {\n    var isRegistered = !!superJson.symbolRegistry.getIdentifier(s);\n    return isRegistered;\n  }\n  return false;\n}, function (s, superJson) {\n  var identifier = superJson.symbolRegistry.getIdentifier(s);\n  return ['symbol', identifier];\n}, function (v) {\n  return v.description;\n}, function (_, a, superJson) {\n  var value = superJson.symbolRegistry.getValue(a[1]);\n  if (!value) {\n    throw new Error('Trying to deserialize unknown symbol');\n  }\n  return value;\n});\nvar constructorToName = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array, Uint8ClampedArray].reduce(function (obj, ctor) {\n  obj[ctor.name] = ctor;\n  return obj;\n}, {});\nvar typedArrayRule = compositeTransformation(isTypedArray, function (v) {\n  return ['typed-array', v.constructor.name];\n}, function (v) {\n  return __spreadArray([], __read(v));\n}, function (v, a) {\n  var ctor = constructorToName[a[1]];\n  if (!ctor) {\n    throw new Error('Trying to deserialize unknown typed array');\n  }\n  return new ctor(v);\n});\nexport function isInstanceOfRegisteredClass(potentialClass, superJson) {\n  if (potentialClass === null || potentialClass === void 0 ? void 0 : potentialClass.constructor) {\n    var isRegistered = !!superJson.classRegistry.getIdentifier(potentialClass.constructor);\n    return isRegistered;\n  }\n  return false;\n}\nvar classRule = compositeTransformation(isInstanceOfRegisteredClass, function (clazz, superJson) {\n  var identifier = superJson.classRegistry.getIdentifier(clazz.constructor);\n  return ['class', identifier];\n}, function (clazz, superJson) {\n  var allowedProps = superJson.classRegistry.getAllowedProps(clazz.constructor);\n  if (!allowedProps) {\n    return __assign({}, clazz);\n  }\n  var result = {};\n  allowedProps.forEach(function (prop) {\n    result[prop] = clazz[prop];\n  });\n  return result;\n}, function (v, a, superJson) {\n  var clazz = superJson.classRegistry.getValue(a[1]);\n  if (!clazz) {\n    throw new Error('Trying to deserialize unknown class - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564');\n  }\n  return Object.assign(Object.create(clazz.prototype), v);\n});\nvar customRule = compositeTransformation(function (value, superJson) {\n  return !!superJson.customTransformerRegistry.findApplicable(value);\n}, function (value, superJson) {\n  var transformer = superJson.customTransformerRegistry.findApplicable(value);\n  return ['custom', transformer.name];\n}, function (value, superJson) {\n  var transformer = superJson.customTransformerRegistry.findApplicable(value);\n  return transformer.serialize(value);\n}, function (v, a, superJson) {\n  var transformer = superJson.customTransformerRegistry.findByName(a[1]);\n  if (!transformer) {\n    throw new Error('Trying to deserialize unknown custom value');\n  }\n  return transformer.deserialize(v);\n});\nvar compositeRules = [classRule, symbolRule, customRule, typedArrayRule];\nexport var transformValue = function transformValue(value, superJson) {\n  var applicableCompositeRule = findArr(compositeRules, function (rule) {\n    return rule.isApplicable(value, superJson);\n  });\n  if (applicableCompositeRule) {\n    return {\n      value: applicableCompositeRule.transform(value, superJson),\n      type: applicableCompositeRule.annotation(value, superJson)\n    };\n  }\n  var applicableSimpleRule = findArr(simpleRules, function (rule) {\n    return rule.isApplicable(value, superJson);\n  });\n  if (applicableSimpleRule) {\n    return {\n      value: applicableSimpleRule.transform(value, superJson),\n      type: applicableSimpleRule.annotation\n    };\n  }\n  return undefined;\n};\nvar simpleRulesByAnnotation = {};\nsimpleRules.forEach(function (rule) {\n  simpleRulesByAnnotation[rule.annotation] = rule;\n});\nexport var untransformValue = function untransformValue(json, type, superJson) {\n  if (isArray(type)) {\n    switch (type[0]) {\n      case 'symbol':\n        return symbolRule.untransform(json, type, superJson);\n      case 'class':\n        return classRule.untransform(json, type, superJson);\n      case 'custom':\n        return customRule.untransform(json, type, superJson);\n      case 'typed-array':\n        return typedArrayRule.untransform(json, type, superJson);\n      default:\n        throw new Error('Unknown transformation: ' + type);\n    }\n  } else {\n    var transformation = simpleRulesByAnnotation[type];\n    if (!transformation) {\n      throw new Error('Unknown transformation: ' + type);\n    }\n    return transformation.untransform(json, superJson);\n  }\n};","map":{"version":3,"names":["isBigint","isDate","isInfinite","isMap","isNaNValue","isRegExp","isSet","isUndefined","isSymbol","isArray","isError","isTypedArray","isURL","findArr","simpleTransformation","isApplicable","annotation","transform","untransform","simpleRules","undefined","v","toString","BigInt","console","error","toISOString","Date","superJson","baseError","name","message","allowedErrorProps","forEach","prop","e","Error","stack","regex","body","slice","lastIndexOf","flags","RegExp","__spreadArray","__read","values","Set","entries","Map","Number","Infinity","URL","compositeTransformation","symbolRule","s","isRegistered","symbolRegistry","getIdentifier","identifier","description","_","a","value","getValue","constructorToName","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","Uint8ClampedArray","reduce","obj","ctor","typedArrayRule","constructor","isInstanceOfRegisteredClass","potentialClass","classRegistry","classRule","clazz","allowedProps","getAllowedProps","__assign","result","Object","assign","create","prototype","customRule","customTransformerRegistry","findApplicable","transformer","serialize","findByName","deserialize","compositeRules","transformValue","applicableCompositeRule","rule","type","applicableSimpleRule","simpleRulesByAnnotation","untransformValue","json","transformation"],"sources":["C:\\Users\\parkj\\Desktop\\OSS\\Git_filemanager\\frontend\\node_modules\\superjson\\src\\transformer.ts"],"sourcesContent":["import {\r\n  isBigint,\r\n  isDate,\r\n  isInfinite,\r\n  isMap,\r\n  isNaNValue,\r\n  isRegExp,\r\n  isSet,\r\n  isUndefined,\r\n  isSymbol,\r\n  isArray,\r\n  isError,\r\n  isTypedArray,\r\n  TypedArrayConstructor,\r\n  isURL,\r\n} from './is';\r\nimport { findArr } from './util';\r\nimport SuperJSON from '.';\r\n\r\nexport type PrimitiveTypeAnnotation = 'number' | 'undefined' | 'bigint';\r\n\r\ntype LeafTypeAnnotation =\r\n  | PrimitiveTypeAnnotation\r\n  | 'regexp'\r\n  | 'Date'\r\n  | 'Error'\r\n  | 'URL';\r\n\r\ntype TypedArrayAnnotation = ['typed-array', string];\r\ntype ClassTypeAnnotation = ['class', string];\r\ntype SymbolTypeAnnotation = ['symbol', string];\r\ntype CustomTypeAnnotation = ['custom', string];\r\n\r\ntype SimpleTypeAnnotation = LeafTypeAnnotation | 'map' | 'set';\r\n\r\ntype CompositeTypeAnnotation =\r\n  | TypedArrayAnnotation\r\n  | ClassTypeAnnotation\r\n  | SymbolTypeAnnotation\r\n  | CustomTypeAnnotation;\r\n\r\nexport type TypeAnnotation = SimpleTypeAnnotation | CompositeTypeAnnotation;\r\n\r\nfunction simpleTransformation<I, O, A extends SimpleTypeAnnotation>(\r\n  isApplicable: (v: any, superJson: SuperJSON) => v is I,\r\n  annotation: A,\r\n  transform: (v: I, superJson: SuperJSON) => O,\r\n  untransform: (v: O, superJson: SuperJSON) => I\r\n) {\r\n  return {\r\n    isApplicable,\r\n    annotation,\r\n    transform,\r\n    untransform,\r\n  };\r\n}\r\n\r\nconst simpleRules = [\r\n  simpleTransformation(\r\n    isUndefined,\r\n    'undefined',\r\n    () => null,\r\n    () => undefined\r\n  ),\r\n  simpleTransformation(\r\n    isBigint,\r\n    'bigint',\r\n    v => v.toString(),\r\n    v => {\r\n      if (typeof BigInt !== 'undefined') {\r\n        return BigInt(v);\r\n      }\r\n\r\n      console.error('Please add a BigInt polyfill.');\r\n\r\n      return v as any;\r\n    }\r\n  ),\r\n  simpleTransformation(\r\n    isDate,\r\n    'Date',\r\n    v => v.toISOString(),\r\n    v => new Date(v)\r\n  ),\r\n\r\n  simpleTransformation(\r\n    isError,\r\n    'Error',\r\n    (v, superJson) => {\r\n      const baseError: any = {\r\n        name: v.name,\r\n        message: v.message,\r\n      };\r\n\r\n      superJson.allowedErrorProps.forEach(prop => {\r\n        baseError[prop] = (v as any)[prop];\r\n      });\r\n\r\n      return baseError;\r\n    },\r\n    (v, superJson) => {\r\n      const e = new Error(v.message);\r\n      e.name = v.name;\r\n      e.stack = v.stack;\r\n\r\n      superJson.allowedErrorProps.forEach(prop => {\r\n        (e as any)[prop] = v[prop];\r\n      });\r\n\r\n      return e;\r\n    }\r\n  ),\r\n\r\n  simpleTransformation(\r\n    isRegExp,\r\n    'regexp',\r\n    v => '' + v,\r\n    regex => {\r\n      const body = regex.slice(1, regex.lastIndexOf('/'));\r\n      const flags = regex.slice(regex.lastIndexOf('/') + 1);\r\n      return new RegExp(body, flags);\r\n    }\r\n  ),\r\n\r\n  simpleTransformation(\r\n    isSet,\r\n    'set',\r\n    // (sets only exist in es6+)\r\n    // eslint-disable-next-line es5/no-es6-methods\r\n    v => [...v.values()],\r\n    v => new Set(v)\r\n  ),\r\n  simpleTransformation(\r\n    isMap,\r\n    'map',\r\n    v => [...v.entries()],\r\n    v => new Map(v)\r\n  ),\r\n\r\n  simpleTransformation<number, 'NaN' | 'Infinity' | '-Infinity', 'number'>(\r\n    (v): v is number => isNaNValue(v) || isInfinite(v),\r\n    'number',\r\n    v => {\r\n      if (isNaNValue(v)) {\r\n        return 'NaN';\r\n      }\r\n\r\n      if (v > 0) {\r\n        return 'Infinity';\r\n      } else {\r\n        return '-Infinity';\r\n      }\r\n    },\r\n    Number\r\n  ),\r\n\r\n  simpleTransformation<number, '-0', 'number'>(\r\n    (v): v is number => v === 0 && 1 / v === -Infinity,\r\n    'number',\r\n    () => {\r\n      return '-0';\r\n    },\r\n    Number\r\n  ),\r\n\r\n  simpleTransformation(\r\n    isURL,\r\n    'URL',\r\n    v => v.toString(),\r\n    v => new URL(v)\r\n  ),\r\n];\r\n\r\nfunction compositeTransformation<I, O, A extends CompositeTypeAnnotation>(\r\n  isApplicable: (v: any, superJson: SuperJSON) => v is I,\r\n  annotation: (v: I, superJson: SuperJSON) => A,\r\n  transform: (v: I, superJson: SuperJSON) => O,\r\n  untransform: (v: O, a: A, superJson: SuperJSON) => I\r\n) {\r\n  return {\r\n    isApplicable,\r\n    annotation,\r\n    transform,\r\n    untransform,\r\n  };\r\n}\r\n\r\nconst symbolRule = compositeTransformation(\r\n  (s, superJson): s is Symbol => {\r\n    if (isSymbol(s)) {\r\n      const isRegistered = !!superJson.symbolRegistry.getIdentifier(s);\r\n      return isRegistered;\r\n    }\r\n    return false;\r\n  },\r\n  (s, superJson) => {\r\n    const identifier = superJson.symbolRegistry.getIdentifier(s);\r\n    return ['symbol', identifier!];\r\n  },\r\n  v => v.description,\r\n  (_, a, superJson) => {\r\n    const value = superJson.symbolRegistry.getValue(a[1]);\r\n    if (!value) {\r\n      throw new Error('Trying to deserialize unknown symbol');\r\n    }\r\n    return value;\r\n  }\r\n);\r\n\r\nconst constructorToName = [\r\n  Int8Array,\r\n  Uint8Array,\r\n  Int16Array,\r\n  Uint16Array,\r\n  Int32Array,\r\n  Uint32Array,\r\n  Float32Array,\r\n  Float64Array,\r\n  Uint8ClampedArray,\r\n].reduce<Record<string, TypedArrayConstructor>>((obj, ctor) => {\r\n  obj[ctor.name] = ctor;\r\n  return obj;\r\n}, {});\r\n\r\nconst typedArrayRule = compositeTransformation(\r\n  isTypedArray,\r\n  v => ['typed-array', v.constructor.name],\r\n  v => [...v],\r\n  (v, a) => {\r\n    const ctor = constructorToName[a[1]];\r\n\r\n    if (!ctor) {\r\n      throw new Error('Trying to deserialize unknown typed array');\r\n    }\r\n\r\n    return new ctor(v);\r\n  }\r\n);\r\n\r\nexport function isInstanceOfRegisteredClass(\r\n  potentialClass: any,\r\n  superJson: SuperJSON\r\n): potentialClass is any {\r\n  if (potentialClass?.constructor) {\r\n    const isRegistered = !!superJson.classRegistry.getIdentifier(\r\n      potentialClass.constructor\r\n    );\r\n    return isRegistered;\r\n  }\r\n  return false;\r\n}\r\n\r\nconst classRule = compositeTransformation(\r\n  isInstanceOfRegisteredClass,\r\n  (clazz, superJson) => {\r\n    const identifier = superJson.classRegistry.getIdentifier(clazz.constructor);\r\n    return ['class', identifier!];\r\n  },\r\n  (clazz, superJson) => {\r\n    const allowedProps = superJson.classRegistry.getAllowedProps(\r\n      clazz.constructor\r\n    );\r\n    if (!allowedProps) {\r\n      return { ...clazz };\r\n    }\r\n\r\n    const result: any = {};\r\n    allowedProps.forEach(prop => {\r\n      result[prop] = clazz[prop];\r\n    });\r\n    return result;\r\n  },\r\n  (v, a, superJson) => {\r\n    const clazz = superJson.classRegistry.getValue(a[1]);\r\n\r\n    if (!clazz) {\r\n      throw new Error(\r\n        'Trying to deserialize unknown class - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564'\r\n      );\r\n    }\r\n\r\n    return Object.assign(Object.create(clazz.prototype), v);\r\n  }\r\n);\r\n\r\nconst customRule = compositeTransformation(\r\n  (value, superJson): value is any => {\r\n    return !!superJson.customTransformerRegistry.findApplicable(value);\r\n  },\r\n  (value, superJson) => {\r\n    const transformer = superJson.customTransformerRegistry.findApplicable(\r\n      value\r\n    )!;\r\n    return ['custom', transformer.name];\r\n  },\r\n  (value, superJson) => {\r\n    const transformer = superJson.customTransformerRegistry.findApplicable(\r\n      value\r\n    )!;\r\n    return transformer.serialize(value);\r\n  },\r\n  (v, a, superJson) => {\r\n    const transformer = superJson.customTransformerRegistry.findByName(a[1]);\r\n    if (!transformer) {\r\n      throw new Error('Trying to deserialize unknown custom value');\r\n    }\r\n    return transformer.deserialize(v);\r\n  }\r\n);\r\n\r\nconst compositeRules = [classRule, symbolRule, customRule, typedArrayRule];\r\n\r\nexport const transformValue = (\r\n  value: any,\r\n  superJson: SuperJSON\r\n): { value: any; type: TypeAnnotation } | undefined => {\r\n  const applicableCompositeRule = findArr(compositeRules, rule =>\r\n    rule.isApplicable(value, superJson)\r\n  );\r\n  if (applicableCompositeRule) {\r\n    return {\r\n      value: applicableCompositeRule.transform(value as never, superJson),\r\n      type: applicableCompositeRule.annotation(value, superJson),\r\n    };\r\n  }\r\n\r\n  const applicableSimpleRule = findArr(simpleRules, rule =>\r\n    rule.isApplicable(value, superJson)\r\n  );\r\n\r\n  if (applicableSimpleRule) {\r\n    return {\r\n      value: applicableSimpleRule.transform(value as never, superJson),\r\n      type: applicableSimpleRule.annotation,\r\n    };\r\n  }\r\n\r\n  return undefined;\r\n};\r\n\r\nconst simpleRulesByAnnotation: Record<string, typeof simpleRules[0]> = {};\r\nsimpleRules.forEach(rule => {\r\n  simpleRulesByAnnotation[rule.annotation] = rule;\r\n});\r\n\r\nexport const untransformValue = (\r\n  json: any,\r\n  type: TypeAnnotation,\r\n  superJson: SuperJSON\r\n) => {\r\n  if (isArray(type)) {\r\n    switch (type[0]) {\r\n      case 'symbol':\r\n        return symbolRule.untransform(json, type, superJson);\r\n      case 'class':\r\n        return classRule.untransform(json, type, superJson);\r\n      case 'custom':\r\n        return customRule.untransform(json, type, superJson);\r\n      case 'typed-array':\r\n        return typedArrayRule.untransform(json, type, superJson);\r\n      default:\r\n        throw new Error('Unknown transformation: ' + type);\r\n    }\r\n  } else {\r\n    const transformation = simpleRulesByAnnotation[type];\r\n    if (!transformation) {\r\n      throw new Error('Unknown transformation: ' + type);\r\n    }\r\n\r\n    return transformation.untransform(json as never, superJson);\r\n  }\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}