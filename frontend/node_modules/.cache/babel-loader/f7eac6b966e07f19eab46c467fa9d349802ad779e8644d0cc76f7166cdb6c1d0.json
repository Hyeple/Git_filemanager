{"ast":null,"code":"import _objectSpread from \"C:/Users/parkj/Desktop/OSS/Git_filemanager/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"C:/Users/parkj/Desktop/OSS/Git_filemanager/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/parkj/Desktop/OSS/Git_filemanager/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/parkj/Desktop/OSS/Git_filemanager/frontend/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/parkj/Desktop/OSS/Git_filemanager/frontend/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/parkj/Desktop/OSS/Git_filemanager/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/parkj/Desktop/OSS/Git_filemanager/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { replaceData, noop, timeUntilStale, getAbortController } from './utils.mjs';\nimport { defaultLogger } from './logger.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { createRetryer, isCancelledError, canFetch } from './retryer.mjs';\nimport { Removable } from './removable.mjs';\n\n// CLASS\nvar Query = /*#__PURE__*/function (_Removable) {\n  _inherits(Query, _Removable);\n  var _super = _createSuper(Query);\n  function Query(config) {\n    var _this;\n    _classCallCheck(this, Query);\n    _this = _super.call(this);\n    _this.abortSignalConsumed = false;\n    _this.defaultOptions = config.defaultOptions;\n    _this.setOptions(config.options);\n    _this.observers = [];\n    _this.cache = config.cache;\n    _this.logger = config.logger || defaultLogger;\n    _this.queryKey = config.queryKey;\n    _this.queryHash = config.queryHash;\n    _this.initialState = config.state || getDefaultState(_this.options);\n    _this.state = _this.initialState;\n    _this.scheduleGc();\n    return _this;\n  }\n  _createClass(Query, [{\n    key: \"meta\",\n    get: function get() {\n      return this.options.meta;\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = _objectSpread(_objectSpread({}, this.defaultOptions), options);\n      this.updateCacheTime(this.options.cacheTime);\n    }\n  }, {\n    key: \"optionalRemove\",\n    value: function optionalRemove() {\n      if (!this.observers.length && this.state.fetchStatus === 'idle') {\n        this.cache.remove(this);\n      }\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(newData, options) {\n      var data = replaceData(this.state.data, newData, this.options); // Set data and mark it as cached\n\n      this.dispatch({\n        data: data,\n        type: 'success',\n        dataUpdatedAt: options == null ? void 0 : options.updatedAt,\n        manual: options == null ? void 0 : options.manual\n      });\n      return data;\n    }\n  }, {\n    key: \"setState\",\n    value: function setState(state, setStateOptions) {\n      this.dispatch({\n        type: 'setState',\n        state: state,\n        setStateOptions: setStateOptions\n      });\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel(options) {\n      var _this$retryer;\n      var promise = this.promise;\n      (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n      return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      _get(_getPrototypeOf(Query.prototype), \"destroy\", this).call(this);\n      this.cancel({\n        silent: true\n      });\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.destroy();\n      this.setState(this.initialState);\n    }\n  }, {\n    key: \"isActive\",\n    value: function isActive() {\n      return this.observers.some(function (observer) {\n        return observer.options.enabled !== false;\n      });\n    }\n  }, {\n    key: \"isDisabled\",\n    value: function isDisabled() {\n      return this.getObserversCount() > 0 && !this.isActive();\n    }\n  }, {\n    key: \"isStale\",\n    value: function isStale() {\n      return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(function (observer) {\n        return observer.getCurrentResult().isStale;\n      });\n    }\n  }, {\n    key: \"isStaleByTime\",\n    value: function isStaleByTime() {\n      var staleTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n    }\n  }, {\n    key: \"onFocus\",\n    value: function onFocus() {\n      var _this$retryer2;\n      var observer = this.observers.find(function (x) {\n        return x.shouldFetchOnWindowFocus();\n      });\n      if (observer) {\n        observer.refetch({\n          cancelRefetch: false\n        });\n      } // Continue fetch if currently paused\n\n      (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n    }\n  }, {\n    key: \"onOnline\",\n    value: function onOnline() {\n      var _this$retryer3;\n      var observer = this.observers.find(function (x) {\n        return x.shouldFetchOnReconnect();\n      });\n      if (observer) {\n        observer.refetch({\n          cancelRefetch: false\n        });\n      } // Continue fetch if currently paused\n\n      (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n    }\n  }, {\n    key: \"addObserver\",\n    value: function addObserver(observer) {\n      if (this.observers.indexOf(observer) === -1) {\n        this.observers.push(observer); // Stop the query from being garbage collected\n\n        this.clearGcTimeout();\n        this.cache.notify({\n          type: 'observerAdded',\n          query: this,\n          observer: observer\n        });\n      }\n    }\n  }, {\n    key: \"removeObserver\",\n    value: function removeObserver(observer) {\n      if (this.observers.indexOf(observer) !== -1) {\n        this.observers = this.observers.filter(function (x) {\n          return x !== observer;\n        });\n        if (!this.observers.length) {\n          // If the transport layer does not support cancellation\n          // we'll let the query continue so the result can be cached\n          if (this.retryer) {\n            if (this.abortSignalConsumed) {\n              this.retryer.cancel({\n                revert: true\n              });\n            } else {\n              this.retryer.cancelRetry();\n            }\n          }\n          this.scheduleGc();\n        }\n        this.cache.notify({\n          type: 'observerRemoved',\n          query: this,\n          observer: observer\n        });\n      }\n    }\n  }, {\n    key: \"getObserversCount\",\n    value: function getObserversCount() {\n      return this.observers.length;\n    }\n  }, {\n    key: \"invalidate\",\n    value: function invalidate() {\n      if (!this.state.isInvalidated) {\n        this.dispatch({\n          type: 'invalidate'\n        });\n      }\n    }\n  }, {\n    key: \"fetch\",\n    value: function fetch(options, fetchOptions) {\n      var _this2 = this;\n      var _this$options$behavio, _context$fetchOptions;\n      if (this.state.fetchStatus !== 'idle') {\n        if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {\n          // Silently cancel current fetch if the user wants to cancel refetches\n          this.cancel({\n            silent: true\n          });\n        } else if (this.promise) {\n          var _this$retryer4;\n\n          // make sure that retries that were potentially cancelled due to unmounts can continue\n          (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry(); // Return current promise if we are already fetching\n\n          return this.promise;\n        }\n      } // Update config if passed, otherwise the config from the last execution is used\n\n      if (options) {\n        this.setOptions(options);\n      } // Use the options from the first observer with a query function if no function is found.\n      // This can happen when the query is hydrated or created with setQueryData.\n\n      if (!this.options.queryFn) {\n        var observer = this.observers.find(function (x) {\n          return x.options.queryFn;\n        });\n        if (observer) {\n          this.setOptions(observer.options);\n        }\n      }\n      if (!Array.isArray(this.options.queryKey)) {\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n        }\n      }\n      var abortController = getAbortController(); // Create query function context\n\n      var queryFnContext = {\n        queryKey: this.queryKey,\n        pageParam: undefined,\n        meta: this.meta\n      }; // Adds an enumerable signal property to the object that\n      // which sets abortSignalConsumed to true when the signal\n      // is read.\n\n      var addSignalProperty = function addSignalProperty(object) {\n        Object.defineProperty(object, 'signal', {\n          enumerable: true,\n          get: function get() {\n            if (abortController) {\n              _this2.abortSignalConsumed = true;\n              return abortController.signal;\n            }\n            return undefined;\n          }\n        });\n      };\n      addSignalProperty(queryFnContext); // Create fetch function\n\n      var fetchFn = function fetchFn() {\n        if (!_this2.options.queryFn) {\n          return Promise.reject('Missing queryFn');\n        }\n        _this2.abortSignalConsumed = false;\n        return _this2.options.queryFn(queryFnContext);\n      }; // Trigger behavior hook\n\n      var context = {\n        fetchOptions: fetchOptions,\n        options: this.options,\n        queryKey: this.queryKey,\n        state: this.state,\n        fetchFn: fetchFn\n      };\n      addSignalProperty(context);\n      (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context); // Store state in case the current fetch needs to be reverted\n\n      this.revertState = this.state; // Set to fetching state if not already in it\n\n      if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n        var _context$fetchOptions2;\n        this.dispatch({\n          type: 'fetch',\n          meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n        });\n      }\n      var onError = function onError(error) {\n        // Optimistically update state if needed\n        if (!(isCancelledError(error) && error.silent)) {\n          _this2.dispatch({\n            type: 'error',\n            error: error\n          });\n        }\n        if (!isCancelledError(error)) {\n          var _this$cache$config$on, _this$cache$config, _this$cache$config$on2, _this$cache$config2;\n\n          // Notify cache callback\n          (_this$cache$config$on = (_this$cache$config = _this2.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, _this2);\n          (_this$cache$config$on2 = (_this$cache$config2 = _this2.cache.config).onSettled) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, _this2.state.data, error, _this2);\n          if (process.env.NODE_ENV !== 'production') {\n            _this2.logger.error(error);\n          }\n        }\n        if (!_this2.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          _this2.scheduleGc();\n        }\n        _this2.isFetchingOptimistic = false;\n      }; // Try to fetch the data\n\n      this.retryer = createRetryer({\n        fn: context.fetchFn,\n        abort: abortController == null ? void 0 : abortController.abort.bind(abortController),\n        onSuccess: function onSuccess(data) {\n          var _this$cache$config$on3, _this$cache$config3, _this$cache$config$on4, _this$cache$config4;\n          if (typeof data === 'undefined') {\n            if (process.env.NODE_ENV !== 'production') {\n              _this2.logger.error(\"Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: \" + _this2.queryHash);\n            }\n            onError(new Error(_this2.queryHash + \" data is undefined\"));\n            return;\n          }\n          _this2.setData(data); // Notify cache callback\n\n          (_this$cache$config$on3 = (_this$cache$config3 = _this2.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on3.call(_this$cache$config3, data, _this2);\n          (_this$cache$config$on4 = (_this$cache$config4 = _this2.cache.config).onSettled) == null ? void 0 : _this$cache$config$on4.call(_this$cache$config4, data, _this2.state.error, _this2);\n          if (!_this2.isFetchingOptimistic) {\n            // Schedule query gc after fetching\n            _this2.scheduleGc();\n          }\n          _this2.isFetchingOptimistic = false;\n        },\n        onError: onError,\n        onFail: function onFail(failureCount, error) {\n          _this2.dispatch({\n            type: 'failed',\n            failureCount: failureCount,\n            error: error\n          });\n        },\n        onPause: function onPause() {\n          _this2.dispatch({\n            type: 'pause'\n          });\n        },\n        onContinue: function onContinue() {\n          _this2.dispatch({\n            type: 'continue'\n          });\n        },\n        retry: context.options.retry,\n        retryDelay: context.options.retryDelay,\n        networkMode: context.options.networkMode\n      });\n      this.promise = this.retryer.promise;\n      return this.promise;\n    }\n  }, {\n    key: \"dispatch\",\n    value: function dispatch(action) {\n      var _this3 = this;\n      var reducer = function reducer(state) {\n        var _action$meta, _action$dataUpdatedAt;\n        switch (action.type) {\n          case 'failed':\n            return _objectSpread(_objectSpread({}, state), {}, {\n              fetchFailureCount: action.failureCount,\n              fetchFailureReason: action.error\n            });\n          case 'pause':\n            return _objectSpread(_objectSpread({}, state), {}, {\n              fetchStatus: 'paused'\n            });\n          case 'continue':\n            return _objectSpread(_objectSpread({}, state), {}, {\n              fetchStatus: 'fetching'\n            });\n          case 'fetch':\n            return _objectSpread(_objectSpread({}, state), {}, {\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n              fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n              fetchStatus: canFetch(_this3.options.networkMode) ? 'fetching' : 'paused'\n            }, !state.dataUpdatedAt && {\n              error: null,\n              status: 'loading'\n            });\n          case 'success':\n            return _objectSpread(_objectSpread({}, state), {}, {\n              data: action.data,\n              dataUpdateCount: state.dataUpdateCount + 1,\n              dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n              error: null,\n              isInvalidated: false,\n              status: 'success'\n            }, !action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            });\n          case 'error':\n            var error = action.error;\n            if (isCancelledError(error) && error.revert && _this3.revertState) {\n              return _objectSpread({}, _this3.revertState);\n            }\n            return _objectSpread(_objectSpread({}, state), {}, {\n              error: error,\n              errorUpdateCount: state.errorUpdateCount + 1,\n              errorUpdatedAt: Date.now(),\n              fetchFailureCount: state.fetchFailureCount + 1,\n              fetchFailureReason: error,\n              fetchStatus: 'idle',\n              status: 'error'\n            });\n          case 'invalidate':\n            return _objectSpread(_objectSpread({}, state), {}, {\n              isInvalidated: true\n            });\n          case 'setState':\n            return _objectSpread(_objectSpread({}, state), action.state);\n        }\n      };\n      this.state = reducer(this.state);\n      notifyManager.batch(function () {\n        _this3.observers.forEach(function (observer) {\n          observer.onQueryUpdate(action);\n        });\n        _this3.cache.notify({\n          query: _this3,\n          type: 'updated',\n          action: action\n        });\n      });\n    }\n  }]);\n  return Query;\n}(Removable);\nfunction getDefaultState(options) {\n  var data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n  var hasData = typeof data !== 'undefined';\n  var initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data: data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle'\n  };\n}\nexport { Query };","map":{"version":3,"names":["Query","_Removable","_inherits","_super","_createSuper","config","_this","_classCallCheck","call","abortSignalConsumed","defaultOptions","setOptions","options","observers","cache","logger","defaultLogger","queryKey","queryHash","initialState","state","getDefaultState","scheduleGc","_createClass","key","get","meta","value","_objectSpread","updateCacheTime","cacheTime","optionalRemove","length","fetchStatus","remove","setData","newData","data","replaceData","dispatch","type","dataUpdatedAt","updatedAt","manual","setState","setStateOptions","cancel","_this$retryer","promise","retryer","then","noop","catch","Promise","resolve","destroy","_get","_getPrototypeOf","prototype","silent","reset","isActive","some","observer","enabled","isDisabled","getObserversCount","isStale","isInvalidated","getCurrentResult","isStaleByTime","staleTime","arguments","undefined","timeUntilStale","onFocus","_this$retryer2","find","x","shouldFetchOnWindowFocus","refetch","cancelRefetch","continue","onOnline","_this$retryer3","shouldFetchOnReconnect","addObserver","indexOf","push","clearGcTimeout","notify","query","removeObserver","filter","revert","cancelRetry","invalidate","fetch","fetchOptions","_this2","_this$options$behavio","_context$fetchOptions","_this$retryer4","continueRetry","queryFn","Array","isArray","process","env","NODE_ENV","error","abortController","getAbortController","queryFnContext","pageParam","addSignalProperty","object","Object","defineProperty","enumerable","signal","fetchFn","reject","context","behavior","onFetch","revertState","fetchMeta","_context$fetchOptions2","onError","isCancelledError","_this$cache$config$on","_this$cache$config","_this$cache$config$on2","_this$cache$config2","onSettled","isFetchingOptimistic","createRetryer","fn","abort","bind","onSuccess","_this$cache$config$on3","_this$cache$config3","_this$cache$config$on4","_this$cache$config4","Error","onFail","failureCount","onPause","onContinue","retry","retryDelay","networkMode","action","_this3","reducer","_action$meta","_action$dataUpdatedAt","fetchFailureCount","fetchFailureReason","canFetch","status","dataUpdateCount","Date","now","errorUpdateCount","errorUpdatedAt","notifyManager","batch","forEach","onQueryUpdate","Removable","initialData","hasData","initialDataUpdatedAt"],"sources":["C:\\Users\\parkj\\Desktop\\OSS\\Git_filemanager\\frontend\\node_modules\\@tanstack\\query-core\\src\\query.ts"],"sourcesContent":["import { getAbortController, noop, replaceData, timeUntilStale } from './utils'\nimport type {\n  InitialDataFunction,\n  QueryKey,\n  QueryOptions,\n  QueryStatus,\n  QueryFunctionContext,\n  QueryMeta,\n  CancelOptions,\n  SetDataOptions,\n  FetchStatus,\n} from './types'\nimport type { QueryCache } from './queryCache'\nimport type { QueryObserver } from './queryObserver'\nimport type { Logger } from './logger'\nimport { defaultLogger } from './logger'\nimport { notifyManager } from './notifyManager'\nimport type { Retryer } from './retryer'\nimport { isCancelledError, canFetch, createRetryer } from './retryer'\nimport { Removable } from './removable'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  cache: QueryCache\n  queryKey: TQueryKey\n  queryHash: string\n  logger?: Logger\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = unknown> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: any\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal?: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n  ) => void\n}\n\nexport interface FetchOptions {\n  cancelRefetch?: boolean\n  meta?: any\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: any\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  initialState: QueryState<TData, TError>\n  revertState?: QueryState<TData, TError>\n  state: QueryState<TData, TError>\n  isFetchingOptimistic?: boolean\n\n  private cache: QueryCache\n  private logger: Logger\n  private promise?: Promise<TData>\n  private retryer?: Retryer<TData>\n  private observers: QueryObserver<any, any, any, any, any>[]\n  private defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  private abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.abortSignalConsumed = false\n    this.defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.cache = config.cache\n    this.logger = config.logger || defaultLogger\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.initialState = config.state || getDefaultState(this.options)\n    this.state = this.initialState\n    this.scheduleGc()\n  }\n\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  private setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.defaultOptions, ...options }\n\n    this.updateCacheTime(this.options.cacheTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.promise\n    this.retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some((observer) => observer.options.enabled !== false)\n  }\n\n  isDisabled(): boolean {\n    return this.getObserversCount() > 0 && !this.isActive()\n  }\n\n  isStale(): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      this.observers.some((observer) => observer.getCurrentResult().isStale)\n    )\n  }\n\n  isStaleByTime(staleTime = 0): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n    )\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    if (observer) {\n      observer.refetch({ cancelRefetch: false })\n    }\n\n    // Continue fetch if currently paused\n    this.retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect())\n\n    if (observer) {\n      observer.refetch({ cancelRefetch: false })\n    }\n\n    // Continue fetch if currently paused\n    this.retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.indexOf(observer) !== -1) {\n      this.observers = this.observers.filter((x) => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({ revert: true })\n          } else {\n            this.retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({ silent: true })\n      } else if (this.promise) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.retryer?.continueRetry()\n        // Return current promise if we are already fetching\n        return this.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (!Array.isArray(this.options.queryKey)) {\n      if (process.env.NODE_ENV !== 'production') {\n        this.logger.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = getAbortController()\n\n    // Create query function context\n    const queryFnContext: QueryFunctionContext<TQueryKey> = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta,\n    }\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true\n            return abortController.signal\n          }\n          return undefined\n        },\n      })\n    }\n\n    addSignalProperty(queryFnContext)\n\n    // Create fetch function\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject('Missing queryFn')\n      }\n      this.abortSignalConsumed = false\n      return this.options.queryFn(queryFnContext)\n    }\n\n    // Trigger behavior hook\n    const context: FetchContext<TQueryFnData, TError, TData, TQueryKey> = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n    }\n\n    addSignalProperty(context)\n\n    this.options.behavior?.onFetch(context)\n\n    // Store state in case the current fetch needs to be reverted\n    this.revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.cache.config.onError?.(error, this as Query<any, any, any, any>)\n        this.cache.config.onSettled?.(\n          this.state.data,\n          error,\n          this as Query<any, any, any, any>,\n        )\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error)\n        }\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      }\n      this.isFetchingOptimistic = false\n    }\n\n    // Try to fetch the data\n    this.retryer = createRetryer({\n      fn: context.fetchFn as () => TData,\n      abort: abortController?.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (typeof data === 'undefined') {\n          if (process.env.NODE_ENV !== 'production') {\n            this.logger.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error(`${this.queryHash} data is undefined`) as any)\n          return\n        }\n\n        this.setData(data as TData)\n\n        // Notify cache callback\n        this.cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n        this.cache.config.onSettled?.(\n          data,\n          this.state.error,\n          this as Query<any, any, any, any>,\n        )\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc()\n        }\n        this.isFetchingOptimistic = false\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n    })\n\n    this.promise = this.retryer.promise\n\n    return this.promise\n  }\n\n  private dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            fetchFailureCount: 0,\n            fetchFailureReason: null,\n            fetchMeta: action.meta ?? null,\n            fetchStatus: canFetch(this.options.networkMode)\n              ? 'fetching'\n              : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading',\n            }),\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error as unknown\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState }\n          }\n\n          return {\n            ...state,\n            error: error as TError,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error as TError,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate(action)\n      })\n\n      this.cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = typeof data !== 'undefined'\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle',\n  }\n}\n"],"mappings":";;;;;;;;;;;;;AA0IA;AAAA,IAEaA,KAAN,0BAAAC,UAAA;EAAAC,SAAA,CAAAF,KAAA,EAAAC,UAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,KAAA;EAsBL,SAAAA,MAAYK,MAAD,EAA8D;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAP,KAAA;IACvEM,KAAA,GAAAH,MAAA,CAAAK,IAAA;IAEAF,KAAA,CAAKG,mBAAL,GAA2B,KAA3B;IACAH,KAAA,CAAKI,cAAL,GAAsBL,MAAM,CAACK,cAA7B;IACAJ,KAAA,CAAKK,UAAL,CAAgBN,MAAM,CAACO,OAAvB;IACAN,KAAA,CAAKO,SAAL,GAAiB,EAAjB;IACAP,KAAA,CAAKQ,KAAL,GAAaT,MAAM,CAACS,KAApB;IACAR,KAAA,CAAKS,MAAL,GAAcV,MAAM,CAACU,MAAP,IAAiBC,aAA/B;IACAV,KAAA,CAAKW,QAAL,GAAgBZ,MAAM,CAACY,QAAvB;IACAX,KAAA,CAAKY,SAAL,GAAiBb,MAAM,CAACa,SAAxB;IACAZ,KAAA,CAAKa,YAAL,GAAoBd,MAAM,CAACe,KAAP,IAAgBC,eAAe,CAACf,KAAA,CAAKM,OAAN,CAAnD;IACAN,KAAA,CAAKc,KAAL,GAAad,KAAA,CAAKa,YAAlB;IACAb,KAAA,CAAKgB,UAAL;IAAA,OAAAhB,KAAA;EACD;EAAAiB,YAAA,CAAAvB,KAAA;IAAAwB,GAAA;IAAAC,GAAA,EAEO,SAAAA,IAAA,EAA0B;MAChC,OAAO,KAAKb,OAAL,CAAac,IAApB;IACD;EAAA;IAAAF,GAAA;IAAAG,KAAA,EAEO,SAAAhB,WACNC,OADgB,EAEV;MACN,KAAKA,OAAL,GAAAgB,aAAA,CAAAA,aAAA,KAAoB,KAAKlB,cAAV,GAA6BE,OAAA,CAA5C;MAEA,KAAKiB,eAAL,CAAqB,IAAK,CAAAjB,OAAL,CAAakB,SAAlC;IACD;EAAA;IAAAN,GAAA;IAAAG,KAAA,EAES,SAAAI,eAAA,EAAiB;MACzB,IAAI,CAAC,KAAKlB,SAAL,CAAemB,MAAhB,IAA0B,IAAK,CAAAZ,KAAL,CAAWa,WAAX,KAA2B,MAAzD,EAAiE;QAC/D,KAAKnB,KAAL,CAAWoB,MAAX,CAAkB,IAAlB;MACD;IACF;EAAA;IAAAV,GAAA;IAAAG,KAAA,EAED,SAAAQ,QACEC,OADK,EAELxB,OAFK,EAGE;MACP,IAAMyB,IAAI,GAAGC,WAAW,CAAC,KAAKlB,KAAL,CAAWiB,IAAZ,EAAkBD,OAAlB,EAA2B,KAAKxB,OAAhC,CAAxB,CADO;;MAIP,KAAK2B,QAAL,CAAc;QACZF,IADY,EACZA,IADY;QAEZG,IAAI,EAAE,SAFM;QAGZC,aAAa,EAAE7B,OAAF,IAAE,gBAAAA,OAAO,CAAE8B,SAHZ;QAIZC,MAAM,EAAE/B,OAAF,IAAE,gBAAAA,OAAO,CAAE+B;OAJnB;MAOA,OAAON,IAAP;IACD;EAAA;IAAAb,GAAA;IAAAG,KAAA,EAED,SAAAiB,SACExB,KADM,EAENyB,eAFM,EAGA;MACN,KAAKN,QAAL,CAAc;QAAEC,IAAI,EAAE,UAAR;QAAoBpB,KAApB,EAAoBA,KAApB;QAA2ByB,eAAA,EAAAA;OAAzC;IACD;EAAA;IAAArB,GAAA;IAAAG,KAAA,EAED,SAAAmB,OAAOlC,OAAD,EAAyC;MAAA,IAAAmC,aAAA;MAC7C,IAAMC,OAAO,GAAG,KAAKA,OAArB;MACA,CAAAD,aAAA,QAAKE,OAAL,qBAAAF,aAAA,CAAcD,MAAd,CAAqBlC,OAArB;MACA,OAAOoC,OAAO,GAAGA,OAAO,CAACE,IAAR,CAAaC,IAAb,EAAmBC,KAAnB,CAAyBD,IAAzB,CAAH,GAAoCE,OAAO,CAACC,OAAR,EAAlD;IACD;EAAA;IAAA9B,GAAA;IAAAG,KAAA,EAED,SAAA4B,QAAA,EAAgB;MACdC,IAAA,CAAAC,eAAA,CAAAzD,KAAA,CAAA0D,SAAA,oBAAAlD,IAAA;MAEA,KAAKsC,MAAL,CAAY;QAAEa,MAAM,EAAE;OAAtB;IACD;EAAA;IAAAnC,GAAA;IAAAG,KAAA,EAED,SAAAiC,MAAA,EAAc;MACZ,KAAKL,OAAL;MACA,IAAK,CAAAX,QAAL,CAAc,KAAKzB,YAAnB;IACD;EAAA;IAAAK,GAAA;IAAAG,KAAA,EAED,SAAAkC,SAAA,EAAoB;MAClB,OAAO,IAAK,CAAAhD,SAAL,CAAeiD,IAAf,CAAqB,UAAAC,QAAD;QAAA,OAAcA,QAAQ,CAACnD,OAAT,CAAiBoD,OAAjB,KAA6B,KAA/D;MAAA,EAAP;IACD;EAAA;IAAAxC,GAAA;IAAAG,KAAA,EAED,SAAAsC,WAAA,EAAsB;MACpB,OAAO,KAAKC,iBAAL,EAA2B,IAA3B,IAAgC,CAAC,KAAKL,QAAL,EAAxC;IACD;EAAA;IAAArC,GAAA;IAAAG,KAAA,EAED,SAAAwC,QAAA,EAAmB;MACjB,OACE,KAAK/C,KAAL,CAAWgD,aAAX,IACA,CAAC,KAAKhD,KAAL,CAAWqB,aADZ,IAEA,KAAK5B,SAAL,CAAeiD,IAAf,CAAqB,UAAAC,QAAD;QAAA,OAAcA,QAAQ,CAACM,gBAAT,EAA4B,CAAAF,OAA9D;MAAA,EAHF;IAKD;EAAA;IAAA3C,GAAA;IAAAG,KAAA,EAED,SAAA2C,cAAA,EAAsC;MAAA,IAAxBC,SAAS,GAAAC,SAAA,CAAAxC,MAAA,QAAAwC,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,CAAb;MACX,OACE,KAAKpD,KAAL,CAAWgD,aAAX,IACA,CAAC,KAAKhD,KAAL,CAAWqB,aADZ,IAEA,CAACiC,cAAc,CAAC,IAAK,CAAAtD,KAAL,CAAWqB,aAAZ,EAA2B8B,SAA3B,CAHjB;IAKD;EAAA;IAAA/C,GAAA;IAAAG,KAAA,EAED,SAAAgD,QAAA,EAAgB;MAAA,IAAAC,cAAA;MACd,IAAMb,QAAQ,GAAG,IAAK,CAAAlD,SAAL,CAAegE,IAAf,CAAqB,UAAAC,CAAD;QAAA,OAAOA,CAAC,CAACC,wBAAF,EAA3B;MAAA,EAAjB;MAEA,IAAIhB,QAAJ,EAAc;QACZA,QAAQ,CAACiB,OAAT,CAAiB;UAAEC,aAAa,EAAE;SAAlC;MACD,CALa;;MAQd,CAAKL,cAAA,QAAA3B,OAAL,qBAAA2B,cAAA,CAAcM,QAAd;IACD;EAAA;IAAA1D,GAAA;IAAAG,KAAA,EAED,SAAAwD,SAAA,EAAiB;MAAA,IAAAC,cAAA;MACf,IAAMrB,QAAQ,GAAG,IAAK,CAAAlD,SAAL,CAAegE,IAAf,CAAqB,UAAAC,CAAD;QAAA,OAAOA,CAAC,CAACO,sBAAF,EAA3B;MAAA,EAAjB;MAEA,IAAItB,QAAJ,EAAc;QACZA,QAAQ,CAACiB,OAAT,CAAiB;UAAEC,aAAa,EAAE;SAAlC;MACD,CALc;;MAQf,CAAKG,cAAA,QAAAnC,OAAL,qBAAAmC,cAAA,CAAcF,QAAd;IACD;EAAA;IAAA1D,GAAA;IAAAG,KAAA,EAED,SAAA2D,YAAYvB,QAAD,EAAyD;MAClE,IAAI,KAAKlD,SAAL,CAAe0E,OAAf,CAAuBxB,QAAvB,MAAqC,CAAC,CAA1C,EAA6C;QAC3C,KAAKlD,SAAL,CAAe2E,IAAf,CAAoBzB,QAApB,EAD2C;;QAI3C,KAAK0B,cAAL;QAEA,IAAK,CAAA3E,KAAL,CAAW4E,MAAX,CAAkB;UAAElD,IAAI,EAAE,eAAR;UAAyBmD,KAAK,EAAE,IAAhC;UAAsC5B,QAAA,EAAAA;SAAxD;MACD;IACF;EAAA;IAAAvC,GAAA;IAAAG,KAAA,EAED,SAAAiE,eAAe7B,QAAD,EAAyD;MACrE,IAAI,KAAKlD,SAAL,CAAe0E,OAAf,CAAuBxB,QAAvB,MAAqC,CAAC,CAA1C,EAA6C;QAC3C,KAAKlD,SAAL,GAAiB,IAAK,CAAAA,SAAL,CAAegF,MAAf,CAAuB,UAAAf,CAAD;UAAA,OAAOA,CAAC,KAAKf,QAAnC;QAAA,EAAjB;QAEA,IAAI,CAAC,KAAKlD,SAAL,CAAemB,MAApB,EAA4B;UAC1B;UACA;UACA,IAAI,KAAKiB,OAAT,EAAkB;YAChB,IAAI,KAAKxC,mBAAT,EAA8B;cAC5B,IAAK,CAAAwC,OAAL,CAAaH,MAAb,CAAoB;gBAAEgD,MAAM,EAAE;eAA9B;YACD,CAFD,MAEO;cACL,IAAK,CAAA7C,OAAL,CAAa8C,WAAb;YACD;UACF;UAED,KAAKzE,UAAL;QACD;QAED,IAAK,CAAAR,KAAL,CAAW4E,MAAX,CAAkB;UAAElD,IAAI,EAAE,iBAAR;UAA2BmD,KAAK,EAAE,IAAlC;UAAwC5B,QAAA,EAAAA;SAA1D;MACD;IACF;EAAA;IAAAvC,GAAA;IAAAG,KAAA,EAED,SAAAuC,kBAAA,EAA4B;MAC1B,OAAO,KAAKrD,SAAL,CAAemB,MAAtB;IACD;EAAA;IAAAR,GAAA;IAAAG,KAAA,EAED,SAAAqE,WAAA,EAAmB;MACjB,IAAI,CAAC,KAAK5E,KAAL,CAAWgD,aAAhB,EAA+B;QAC7B,KAAK7B,QAAL,CAAc;UAAEC,IAAI,EAAE;SAAtB;MACD;IACF;EAAA;IAAAhB,GAAA;IAAAG,KAAA,EAED,SAAAsE,MACErF,OADG,EAEHsF,YAFG,EAGa;MAAA,IAAAC,MAAA;MAAA,IAAAC,qBAAA,EAAAC,qBAAA;MAChB,IAAI,KAAKjF,KAAL,CAAWa,WAAX,KAA2B,MAA/B,EAAuC;QACrC,IAAI,KAAKb,KAAL,CAAWqB,aAAX,IAA4ByD,YAA5B,IAA4B,QAAAA,YAAY,CAAEjB,aAA9C,EAA6D;UAC3D;UACA,KAAKnC,MAAL,CAAY;YAAEa,MAAM,EAAE;WAAtB;QACD,CAHD,MAGO,IAAI,IAAK,CAAAX,OAAT,EAAkB;UAAA,IAAAsD,cAAA;;UACvB;UACA,CAAAA,cAAA,QAAKrD,OAAL,qBAAAqD,cAAA,CAAcC,aAAd,GAFuB;;UAIvB,OAAO,KAAKvD,OAAZ;QACD;MACF,CAXe;;MAchB,IAAIpC,OAAJ,EAAa;QACX,IAAK,CAAAD,UAAL,CAAgBC,OAAhB;MACD,CAhBe;MAmBhB;;MACA,IAAI,CAAC,KAAKA,OAAL,CAAa4F,OAAlB,EAA2B;QACzB,IAAMzC,QAAQ,GAAG,IAAK,CAAAlD,SAAL,CAAegE,IAAf,CAAqB,UAAAC,CAAD;UAAA,OAAOA,CAAC,CAAClE,OAAF,CAAU4F,OAArC;QAAA,EAAjB;QACA,IAAIzC,QAAJ,EAAc;UACZ,KAAKpD,UAAL,CAAgBoD,QAAQ,CAACnD,OAAzB;QACD;MACF;MAED,IAAI,CAAC6F,KAAK,CAACC,OAAN,CAAc,KAAK9F,OAAL,CAAaK,QAA3B,CAAL,EAA2C;QACzC,IAAI0F,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;UACzC,IAAK,CAAA9F,MAAL,CAAY+F,KAAZ;QAGD;MACF;MAED,IAAMC,eAAe,GAAGC,kBAAkB,EAA1C,CAnCgB;;MAsChB,IAAMC,cAA+C,GAAG;QACtDhG,QAAQ,EAAE,KAAKA,QADuC;QAEtDiG,SAAS,EAAEzC,SAF2C;QAGtD/C,IAAI,EAAE,IAAK,CAAAA;MAH2C,CAAxD,CAtCgB;MA6ChB;MACA;;MACA,IAAMyF,iBAAiB,GAAI,SAArBA,iBAAiBA,CAAIC,MAAD,EAAqB;QAC7CC,MAAM,CAACC,cAAP,CAAsBF,MAAtB,EAA8B,QAA9B,EAAwC;UACtCG,UAAU,EAAE,IAD0B;UAEtC9F,GAAG,EAAE,SAAAA,IAAA,EAAM;YACT,IAAIsF,eAAJ,EAAqB;cACnBZ,MAAK,CAAA1F,mBAAL,GAA2B,IAA3B;cACA,OAAOsG,eAAe,CAACS,MAAvB;YACD;YACD,OAAO/C,SAAP;UACD;SARH;OADF;MAaA0C,iBAAiB,CAACF,cAAD,CAAjB,CA5DgB;;MA+DhB,IAAMQ,OAAO,GAAG,SAAVA,OAAOA,CAAA,EAAS;QACpB,IAAI,CAACtB,MAAA,CAAKvF,OAAL,CAAa4F,OAAlB,EAA2B;UACzB,OAAOnD,OAAO,CAACqE,MAAR,CAAe,iBAAf,CAAP;QACD;QACDvB,MAAK,CAAA1F,mBAAL,GAA2B,KAA3B;QACA,OAAO0F,MAAA,CAAKvF,OAAL,CAAa4F,OAAb,CAAqBS,cAArB,CAAP;MACD,CAND,CA/DgB;;MAwEhB,IAAMU,OAA6D,GAAG;QACpEzB,YADoE,EACpEA,YADoE;QAEpEtF,OAAO,EAAE,KAAKA,OAFsD;QAGpEK,QAAQ,EAAE,KAAKA,QAHqD;QAIpEG,KAAK,EAAE,KAAKA,KAJwD;QAKpEqG,OAAA,EAAAA;OALF;MAQAN,iBAAiB,CAACQ,OAAD,CAAjB;MAEA,CAAKvB,qBAAA,QAAAxF,OAAL,CAAagH,QAAb,qBAAAxB,qBAAA,CAAuByB,OAAvB,CAA+BF,OAA/B,EAlFgB;;MAqFhB,KAAKG,WAAL,GAAmB,IAAK,CAAA1G,KAAxB,CArFgB;;MAwFhB,IACE,KAAKA,KAAL,CAAWa,WAAX,KAA2B,MAA3B,IACA,IAAK,CAAAb,KAAL,CAAW2G,SAAX,OAAA1B,qBAAA,GAAyBsB,OAAO,CAACzB,YAAjC,qBAAyBG,qBAAsB,CAAA3E,IAA/C,CAFF,EAGE;QAAA,IAAAsG,sBAAA;QACA,KAAKzF,QAAL,CAAc;UAAEC,IAAI,EAAE,OAAR;UAAiBd,IAAI,EAAE,CAAAsG,sBAAA,GAAAL,OAAO,CAACzB,YAAV,qBAAE8B,sBAAsB,CAAAtG;SAA3D;MACD;MAED,IAAMuG,OAAO,GAAI,SAAXA,OAAOA,CAAInB,KAAD,EAA0C;QACxD;QACA,IAAI,EAAEoB,gBAAgB,CAACpB,KAAD,CAAhB,IAA2BA,KAAK,CAACnD,MAAnC,CAAJ,EAAgD;UAC9CwC,MAAA,CAAK5D,QAAL,CAAc;YACZC,IAAI,EAAE,OADM;YAEZsE,KAAK,EAAEA;WAFT;QAID;QAED,IAAI,CAACoB,gBAAgB,CAACpB,KAAD,CAArB,EAA8B;UAAA,IAAAqB,qBAAA,EAAAC,kBAAA,EAAAC,sBAAA,EAAAC,mBAAA;;UAC5B;UACA,CAAKH,qBAAA,IAAAC,kBAAA,GAAAjC,MAAA,CAAArF,KAAL,CAAWT,MAAX,EAAkB4H,OAAlB,KAA4B,gBAAAE,qBAAA,CAAA3H,IAAA,CAAA4H,kBAAA,EAAAtB,KAA5B,EAAmCX,MAAnC;UACA,CAAAkC,sBAAA,IAAAC,mBAAA,GAAAnC,MAAA,CAAKrF,KAAL,CAAWT,MAAX,EAAkBkI,SAAlB,qBAAAF,sBAAA,CAAA7H,IAAA,CAAA8H,mBAAA,EACEnC,MAAK,CAAA/E,KAAL,CAAWiB,IADb,EAEEyE,KAFF,EAGEX,MAHF;UAMA,IAAIQ,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;YACzCV,MAAA,CAAKpF,MAAL,CAAY+F,KAAZ,CAAkBA,KAAlB;UACD;QACF;QAED,IAAI,CAACX,MAAK,CAAAqC,oBAAV,EAAgC;UAC9B;UACArC,MAAA,CAAK7E,UAAL;QACD;QACD6E,MAAK,CAAAqC,oBAAL,GAA4B,KAA5B;MACD,CA5BD,CA/FgB;;MA8HhB,IAAK,CAAAvF,OAAL,GAAewF,aAAa,CAAC;QAC3BC,EAAE,EAAEf,OAAO,CAACF,OADe;QAE3BkB,KAAK,EAAE5B,eAAF,oBAAEA,eAAe,CAAE4B,KAAjB,CAAuBC,IAAvB,CAA4B7B,eAA5B,CAFoB;QAG3B8B,SAAS,EAAG,SAAAA,UAAAxG,IAAD,EAAU;UAAA,IAAAyG,sBAAA,EAAAC,mBAAA,EAAAC,sBAAA,EAAAC,mBAAA;UACnB,IAAI,OAAO5G,IAAP,KAAgB,WAApB,EAAiC;YAC/B,IAAIsE,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;cACzCV,MAAA,CAAKpF,MAAL,CAAY+F,KAAZ,4IAC2IX,MAAA,CAAKjF,SADhJ;YAGD;YACD+G,OAAO,CAAC,IAAIiB,KAAJ,CAAa/C,MAAK,CAAAjF,SAAlB,wBAAD,CAAP;YACA;UACD;UAEDiF,MAAA,CAAKhE,OAAL,CAAaE,IAAb,EAXmB;;UAcnB,CAAKyG,sBAAA,IAAAC,mBAAA,GAAA5C,MAAA,CAAArF,KAAL,CAAWT,MAAX,EAAkBwI,SAAlB,KAA8B,gBAAAC,sBAAA,CAAAtI,IAAA,CAAAuI,mBAAA,EAAA1G,IAA9B,EAAoC8D,MAApC;UACA,CAAA6C,sBAAA,IAAAC,mBAAA,GAAA9C,MAAA,CAAKrF,KAAL,CAAWT,MAAX,EAAkBkI,SAAlB,qBAAAS,sBAAA,CAAAxI,IAAA,CAAAyI,mBAAA,EACE5G,IADF,EAEE8D,MAAK,CAAA/E,KAAL,CAAW0F,KAFb,EAGEX,MAHF;UAMA,IAAI,CAACA,MAAK,CAAAqC,oBAAV,EAAgC;YAC9B;YACArC,MAAA,CAAK7E,UAAL;UACD;UACD6E,MAAK,CAAAqC,oBAAL,GAA4B,KAA5B;SA5ByB;QA8B3BP,OA9B2B,EA8B3BA,OA9B2B;QA+B3BkB,MAAM,EAAE,SAAAA,OAACC,YAAD,EAAetC,KAAf,EAAyB;UAC/BX,MAAA,CAAK5D,QAAL,CAAc;YAAEC,IAAI,EAAE,QAAR;YAAkB4G,YAAlB,EAAkBA,YAAlB;YAAgCtC,KAAA,EAAAA;WAA9C;SAhCyB;QAkC3BuC,OAAO,EAAE,SAAAA,QAAA,EAAM;UACblD,MAAA,CAAK5D,QAAL,CAAc;YAAEC,IAAI,EAAE;WAAtB;SAnCyB;QAqC3B8G,UAAU,EAAE,SAAAA,WAAA,EAAM;UAChBnD,MAAA,CAAK5D,QAAL,CAAc;YAAEC,IAAI,EAAE;WAAtB;SAtCyB;QAwC3B+G,KAAK,EAAE5B,OAAO,CAAC/G,OAAR,CAAgB2I,KAxCI;QAyC3BC,UAAU,EAAE7B,OAAO,CAAC/G,OAAR,CAAgB4I,UAzCD;QA0C3BC,WAAW,EAAE9B,OAAO,CAAC/G,OAAR,CAAgB6I;MA1CF,CAAD,CAA5B;MA6CA,KAAKzG,OAAL,GAAe,IAAK,CAAAC,OAAL,CAAaD,OAA5B;MAEA,OAAO,KAAKA,OAAZ;IACD;EAAA;IAAAxB,GAAA;IAAAG,KAAA,EAEO,SAAAY,SAASmH,MAAD,EAAsC;MAAA,IAAAC,MAAA;MACpD,IAAMC,OAAO,GACX,SADIA,OAAOA,CACXxI,KADc,EAEgB;QAAA,IAAAyI,YAAA,EAAAC,qBAAA;QAC9B,QAAQJ,MAAM,CAAClH,IAAf;UACE,KAAK,QAAL;YACE,OAAAZ,aAAA,CAAAA,aAAA,KACKR,KADE;cAEL2I,iBAAiB,EAAEL,MAAM,CAACN,YAFrB;cAGLY,kBAAkB,EAAEN,MAAM,CAAC5C;YAAA;UAE/B,KAAK,OAAL;YACE,OAAAlF,aAAA,CAAAA,aAAA,KACKR,KADE;cAELa,WAAW,EAAE;YAAA;UAEjB,KAAK,UAAL;YACE,OAAAL,aAAA,CAAAA,aAAA,KACKR,KADE;cAELa,WAAW,EAAE;YAAA;UAEjB,KAAK,OAAL;YACE,OAAAL,aAAA,CAAAA,aAAA,KACKR,KADE;cAEL2I,iBAAiB,EAAE,CAFd;cAGLC,kBAAkB,EAAE,IAHf;cAILjC,SAAS,EAAE,CAAA8B,YAAA,GAAAH,MAAM,CAAChI,IAAT,YAAAmI,YAAA,GAAiB,IAJrB;cAKL5H,WAAW,EAAEgI,QAAQ,CAACN,MAAK,CAAA/I,OAAL,CAAa6I,WAAd,CAAR,GACT,UADS,GAET;YAPC,GAQD,CAACrI,KAAK,CAACqB,aAAP,IAAwB;cAC1BqE,KAAK,EAAE,IADmB;cAE1BoD,MAAM,EAAE;aAFV;UAKJ,KAAK,SAAL;YACE,OAAAtI,aAAA,CAAAA,aAAA,KACKR,KADE;cAELiB,IAAI,EAAEqH,MAAM,CAACrH,IAFR;cAGL8H,eAAe,EAAE/I,KAAK,CAAC+I,eAAN,GAAwB,CAHpC;cAIL1H,aAAa,GAAAqH,qBAAA,GAAEJ,MAAM,CAACjH,aAAT,YAAAqH,qBAAA,GAA0BM,IAAI,CAACC,GAAL,EAJlC;cAKLvD,KAAK,EAAE,IALF;cAML1C,aAAa,EAAE,KANV;cAOL8F,MAAM,EAAE;YAPH,GAQD,CAACR,MAAM,CAAC/G,MAAR,IAAkB;cACpBV,WAAW,EAAE,MADO;cAEpB8H,iBAAiB,EAAE,CAFC;cAGpBC,kBAAkB,EAAE;aAHtB;UAMJ,KAAK,OAAL;YACE,IAAMlD,KAAK,GAAG4C,MAAM,CAAC5C,KAArB;YAEA,IAAIoB,gBAAgB,CAACpB,KAAD,CAAhB,IAA2BA,KAAK,CAAChB,MAAjC,IAA2C6D,MAAK,CAAA7B,WAApD,EAAiE;cAC/D,OAAAlG,aAAA,KAAY+H,MAAK,CAAA7B,WAAA;YAClB;YAED,OAAAlG,aAAA,CAAAA,aAAA,KACKR,KADE;cAEL0F,KAAK,EAAEA,KAFF;cAGLwD,gBAAgB,EAAElJ,KAAK,CAACkJ,gBAAN,GAAyB,CAHtC;cAILC,cAAc,EAAEH,IAAI,CAACC,GAAL,EAJX;cAKLN,iBAAiB,EAAE3I,KAAK,CAAC2I,iBAAN,GAA0B,CALxC;cAMLC,kBAAkB,EAAElD,KANf;cAOL7E,WAAW,EAAE,MAPR;cAQLiI,MAAM,EAAE;YAAA;UAEZ,KAAK,YAAL;YACE,OAAAtI,aAAA,CAAAA,aAAA,KACKR,KADE;cAELgD,aAAa,EAAE;YAAA;UAEnB,KAAK,UAAL;YACE,OAAAxC,aAAA,CAAAA,aAAA,KACKR,KADE,GAEFsI,MAAM,CAACtI,KAAA;QAvEhB;OAHF;MA+EA,KAAKA,KAAL,GAAawI,OAAO,CAAC,KAAKxI,KAAN,CAApB;MAEAoJ,aAAa,CAACC,KAAd,CAAoB,YAAM;QACxBd,MAAA,CAAK9I,SAAL,CAAe6J,OAAf,CAAwB,UAAA3G,QAAD,EAAc;UACnCA,QAAQ,CAAC4G,aAAT,CAAuBjB,MAAvB;SADF;QAIAC,MAAK,CAAA7I,KAAL,CAAW4E,MAAX,CAAkB;UAAEC,KAAK,EAAEgE,MAAT;UAAenH,IAAI,EAAE,SAArB;UAAgCkH,MAAA,EAAAA;SAAlD;OALF;IAOD;EAAA;EAAA,OAAA1J,KAAA;AAAA,EAjcO4K,SALH;AAycP,SAASvJ,eAATA,CAMET,OANF,EAO6B;EAC3B,IAAMyB,IAAI,GACR,OAAOzB,OAAO,CAACiK,WAAf,KAA+B,UAA/B,GACKjK,OAAO,CAACiK,WAAT,EADJ,GAEIjK,OAAO,CAACiK,WAHd;EAKA,IAAMC,OAAO,GAAG,OAAOzI,IAAP,KAAgB,WAAhC;EAEA,IAAM0I,oBAAoB,GAAGD,OAAO,GAChC,OAAOlK,OAAO,CAACmK,oBAAf,KAAwC,UAAxC,GACGnK,OAAO,CAACmK,oBAAT,EADF,GAEEnK,OAAO,CAACmK,oBAHsB,GAIhC,CAJJ;EAMA,OAAO;IACL1I,IADK,EACLA,IADK;IAEL8H,eAAe,EAAE,CAFZ;IAGL1H,aAAa,EAAEqI,OAAO,GAAGC,oBAAH,IAAG,OAAAA,oBAAH,GAA2BX,IAAI,CAACC,GAAL,EAA3B,GAAwC,CAHzD;IAILvD,KAAK,EAAE,IAJF;IAKLwD,gBAAgB,EAAE,CALb;IAMLC,cAAc,EAAE,CANX;IAOLR,iBAAiB,EAAE,CAPd;IAQLC,kBAAkB,EAAE,IARf;IASLjC,SAAS,EAAE,IATN;IAUL3D,aAAa,EAAE,KAVV;IAWL8F,MAAM,EAAEY,OAAO,GAAG,SAAH,GAAe,SAXzB;IAYL7I,WAAW,EAAE;GAZf;AAcD"},"metadata":{},"sourceType":"module","externalDependencies":[]}