{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\nimport { isArray, isEmptyObject, isMap, isPlainObject, isPrimitive, isSet } from './is';\nimport { escapeKey, stringifyPath } from './pathstringifier';\nimport { isInstanceOfRegisteredClass, transformValue, untransformValue } from './transformer';\nimport { includes, forEach } from './util';\nimport { parsePath } from './pathstringifier';\nimport { getDeep, setDeep } from './accessDeep';\nfunction traverse(tree, walker, origin) {\n  if (origin === void 0) {\n    origin = [];\n  }\n  if (!tree) {\n    return;\n  }\n  if (!isArray(tree)) {\n    forEach(tree, function (subtree, key) {\n      return traverse(subtree, walker, __spreadArray(__spreadArray([], __read(origin)), __read(parsePath(key))));\n    });\n    return;\n  }\n  var _a = __read(tree, 2),\n    nodeValue = _a[0],\n    children = _a[1];\n  if (children) {\n    forEach(children, function (child, key) {\n      traverse(child, walker, __spreadArray(__spreadArray([], __read(origin)), __read(parsePath(key))));\n    });\n  }\n  walker(nodeValue, origin);\n}\nexport function applyValueAnnotations(plain, annotations, superJson) {\n  traverse(annotations, function (type, path) {\n    plain = setDeep(plain, path, function (v) {\n      return untransformValue(v, type, superJson);\n    });\n  });\n  return plain;\n}\nexport function applyReferentialEqualityAnnotations(plain, annotations) {\n  function apply(identicalPaths, path) {\n    var object = getDeep(plain, parsePath(path));\n    identicalPaths.map(parsePath).forEach(function (identicalObjectPath) {\n      plain = setDeep(plain, identicalObjectPath, function () {\n        return object;\n      });\n    });\n  }\n  if (isArray(annotations)) {\n    var _a = __read(annotations, 2),\n      root = _a[0],\n      other = _a[1];\n    root.forEach(function (identicalPath) {\n      plain = setDeep(plain, parsePath(identicalPath), function () {\n        return plain;\n      });\n    });\n    if (other) {\n      forEach(other, apply);\n    }\n  } else {\n    forEach(annotations, apply);\n  }\n  return plain;\n}\nvar isDeep = function isDeep(object, superJson) {\n  return isPlainObject(object) || isArray(object) || isMap(object) || isSet(object) || isInstanceOfRegisteredClass(object, superJson);\n};\nfunction addIdentity(object, path, identities) {\n  var existingSet = identities.get(object);\n  if (existingSet) {\n    existingSet.push(path);\n  } else {\n    identities.set(object, [path]);\n  }\n}\nexport function generateReferentialEqualityAnnotations(identitites) {\n  var result = {};\n  var rootEqualityPaths = undefined;\n  identitites.forEach(function (paths) {\n    if (paths.length <= 1) {\n      return;\n    }\n    var _a = __read(paths.map(function (path) {\n        return path.map(String);\n      }).sort(function (a, b) {\n        return a.length - b.length;\n      })),\n      shortestPath = _a[0],\n      identicalPaths = _a.slice(1);\n    if (shortestPath.length === 0) {\n      rootEqualityPaths = identicalPaths.map(stringifyPath);\n    } else {\n      result[stringifyPath(shortestPath)] = identicalPaths.map(stringifyPath);\n    }\n  });\n  if (rootEqualityPaths) {\n    if (isEmptyObject(result)) {\n      return [rootEqualityPaths];\n    } else {\n      return [rootEqualityPaths, result];\n    }\n  } else {\n    return isEmptyObject(result) ? undefined : result;\n  }\n}\nexport var walker = function walker(object, identities, superJson, path, objectsInThisPath) {\n  var _a;\n  if (path === void 0) {\n    path = [];\n  }\n  if (objectsInThisPath === void 0) {\n    objectsInThisPath = [];\n  }\n  if (!isPrimitive(object)) {\n    addIdentity(object, path, identities);\n  }\n  if (!isDeep(object, superJson)) {\n    var transformed_1 = transformValue(object, superJson);\n    if (transformed_1) {\n      return {\n        transformedValue: transformed_1.value,\n        annotations: [transformed_1.type]\n      };\n    } else {\n      return {\n        transformedValue: object\n      };\n    }\n  }\n  if (includes(objectsInThisPath, object)) {\n    return {\n      transformedValue: null\n    };\n  }\n  var transformationResult = transformValue(object, superJson);\n  var transformed = (_a = transformationResult === null || transformationResult === void 0 ? void 0 : transformationResult.value) !== null && _a !== void 0 ? _a : object;\n  if (!isPrimitive(object)) {\n    objectsInThisPath = __spreadArray(__spreadArray([], __read(objectsInThisPath)), [object]);\n  }\n  var transformedValue = isArray(transformed) ? [] : {};\n  var innerAnnotations = {};\n  forEach(transformed, function (value, index) {\n    var recursiveResult = walker(value, identities, superJson, __spreadArray(__spreadArray([], __read(path)), [index]), objectsInThisPath);\n    transformedValue[index] = recursiveResult.transformedValue;\n    if (isArray(recursiveResult.annotations)) {\n      innerAnnotations[index] = recursiveResult.annotations;\n    } else if (isPlainObject(recursiveResult.annotations)) {\n      forEach(recursiveResult.annotations, function (tree, key) {\n        innerAnnotations[escapeKey(index) + '.' + key] = tree;\n      });\n    }\n  });\n  if (isEmptyObject(innerAnnotations)) {\n    return {\n      transformedValue: transformedValue,\n      annotations: !!transformationResult ? [transformationResult.type] : undefined\n    };\n  } else {\n    return {\n      transformedValue: transformedValue,\n      annotations: !!transformationResult ? [transformationResult.type, innerAnnotations] : innerAnnotations\n    };\n  }\n};","map":{"version":3,"names":["isArray","isEmptyObject","isMap","isPlainObject","isPrimitive","isSet","escapeKey","stringifyPath","isInstanceOfRegisteredClass","transformValue","untransformValue","includes","forEach","parsePath","getDeep","setDeep","traverse","tree","walker","origin","subtree","key","__spreadArray","__read","_a","nodeValue","children","child","applyValueAnnotations","plain","annotations","superJson","type","path","v","applyReferentialEqualityAnnotations","apply","identicalPaths","object","map","identicalObjectPath","root","other","identicalPath","isDeep","addIdentity","identities","existingSet","get","push","set","generateReferentialEqualityAnnotations","identitites","result","rootEqualityPaths","undefined","paths","length","String","sort","a","b","shortestPath","slice","objectsInThisPath","transformed_1","transformedValue","value","transformationResult","transformed","innerAnnotations","index","recursiveResult"],"sources":["C:\\Users\\parkj\\Desktop\\OSS\\Git_filemanager\\frontend\\node_modules\\superjson\\src\\plainer.ts"],"sourcesContent":["import {\r\n  isArray,\r\n  isEmptyObject,\r\n  isMap,\r\n  isPlainObject,\r\n  isPrimitive,\r\n  isSet,\r\n} from './is';\r\nimport { escapeKey, stringifyPath } from './pathstringifier';\r\nimport {\r\n  isInstanceOfRegisteredClass,\r\n  transformValue,\r\n  TypeAnnotation,\r\n  untransformValue,\r\n} from './transformer';\r\nimport { includes, forEach } from './util';\r\nimport { parsePath } from './pathstringifier';\r\nimport { getDeep, setDeep } from './accessDeep';\r\nimport SuperJSON from '.';\r\n\r\ntype Tree<T> = InnerNode<T> | Leaf<T>;\r\ntype Leaf<T> = [T];\r\ntype InnerNode<T> = [T, Record<string, Tree<T>>];\r\n\r\nexport type MinimisedTree<T> = Tree<T> | Record<string, Tree<T>> | undefined;\r\n\r\nfunction traverse<T>(\r\n  tree: MinimisedTree<T>,\r\n  walker: (v: T, path: string[]) => void,\r\n  origin: string[] = []\r\n): void {\r\n  if (!tree) {\r\n    return;\r\n  }\r\n\r\n  if (!isArray(tree)) {\r\n    forEach(tree, (subtree, key) =>\r\n      traverse(subtree, walker, [...origin, ...parsePath(key)])\r\n    );\r\n    return;\r\n  }\r\n\r\n  const [nodeValue, children] = tree;\r\n  if (children) {\r\n    forEach(children, (child, key) => {\r\n      traverse(child, walker, [...origin, ...parsePath(key)]);\r\n    });\r\n  }\r\n\r\n  walker(nodeValue, origin);\r\n}\r\n\r\nexport function applyValueAnnotations(\r\n  plain: any,\r\n  annotations: MinimisedTree<TypeAnnotation>,\r\n  superJson: SuperJSON\r\n) {\r\n  traverse(annotations, (type, path) => {\r\n    plain = setDeep(plain, path, v => untransformValue(v, type, superJson));\r\n  });\r\n\r\n  return plain;\r\n}\r\n\r\nexport function applyReferentialEqualityAnnotations(\r\n  plain: any,\r\n  annotations: ReferentialEqualityAnnotations\r\n) {\r\n  function apply(identicalPaths: string[], path: string) {\r\n    const object = getDeep(plain, parsePath(path));\r\n\r\n    identicalPaths.map(parsePath).forEach(identicalObjectPath => {\r\n      plain = setDeep(plain, identicalObjectPath, () => object);\r\n    });\r\n  }\r\n\r\n  if (isArray(annotations)) {\r\n    const [root, other] = annotations;\r\n    root.forEach(identicalPath => {\r\n      plain = setDeep(plain, parsePath(identicalPath), () => plain);\r\n    });\r\n\r\n    if (other) {\r\n      forEach(other, apply);\r\n    }\r\n  } else {\r\n    forEach(annotations, apply);\r\n  }\r\n\r\n  return plain;\r\n}\r\n\r\nconst isDeep = (object: any, superJson: SuperJSON): boolean =>\r\n  isPlainObject(object) ||\r\n  isArray(object) ||\r\n  isMap(object) ||\r\n  isSet(object) ||\r\n  isInstanceOfRegisteredClass(object, superJson);\r\n\r\nfunction addIdentity(object: any, path: any[], identities: Map<any, any[][]>) {\r\n  const existingSet = identities.get(object);\r\n\r\n  if (existingSet) {\r\n    existingSet.push(path);\r\n  } else {\r\n    identities.set(object, [path]);\r\n  }\r\n}\r\n\r\ninterface Result {\r\n  transformedValue: any;\r\n  annotations?: MinimisedTree<TypeAnnotation>;\r\n}\r\n\r\nexport type ReferentialEqualityAnnotations =\r\n  | Record<string, string[]>\r\n  | [string[]]\r\n  | [string[], Record<string, string[]>];\r\n\r\nexport function generateReferentialEqualityAnnotations(\r\n  identitites: Map<any, any[][]>\r\n): ReferentialEqualityAnnotations | undefined {\r\n  const result: Record<string, string[]> = {};\r\n  let rootEqualityPaths: string[] | undefined = undefined;\r\n\r\n  identitites.forEach(paths => {\r\n    if (paths.length <= 1) {\r\n      return;\r\n    }\r\n\r\n    const [shortestPath, ...identicalPaths] = paths\r\n      .map(path => path.map(String))\r\n      .sort((a, b) => a.length - b.length);\r\n\r\n    if (shortestPath.length === 0) {\r\n      rootEqualityPaths = identicalPaths.map(stringifyPath);\r\n    } else {\r\n      result[stringifyPath(shortestPath)] = identicalPaths.map(stringifyPath);\r\n    }\r\n  });\r\n\r\n  if (rootEqualityPaths) {\r\n    if (isEmptyObject(result)) {\r\n      return [rootEqualityPaths];\r\n    } else {\r\n      return [rootEqualityPaths, result];\r\n    }\r\n  } else {\r\n    return isEmptyObject(result) ? undefined : result;\r\n  }\r\n}\r\n\r\nexport const walker = (\r\n  object: any,\r\n  identities: Map<any, any[][]>,\r\n  superJson: SuperJSON,\r\n  path: any[] = [],\r\n  objectsInThisPath: any[] = []\r\n): Result => {\r\n  if (!isPrimitive(object)) {\r\n    addIdentity(object, path, identities);\r\n  }\r\n\r\n  if (!isDeep(object, superJson)) {\r\n    const transformed = transformValue(object, superJson);\r\n    if (transformed) {\r\n      return {\r\n        transformedValue: transformed.value,\r\n        annotations: [transformed.type],\r\n      };\r\n    } else {\r\n      return {\r\n        transformedValue: object,\r\n      };\r\n    }\r\n  }\r\n\r\n  if (includes(objectsInThisPath, object)) {\r\n    return {\r\n      transformedValue: null,\r\n    };\r\n  }\r\n\r\n  const transformationResult = transformValue(object, superJson);\r\n  const transformed = transformationResult?.value ?? object;\r\n\r\n  if (!isPrimitive(object)) {\r\n    objectsInThisPath = [...objectsInThisPath, object];\r\n  }\r\n\r\n  const transformedValue: any = isArray(transformed) ? [] : {};\r\n  const innerAnnotations: Record<string, Tree<TypeAnnotation>> = {};\r\n\r\n  forEach(transformed, (value, index) => {\r\n    const recursiveResult = walker(\r\n      value,\r\n      identities,\r\n      superJson,\r\n      [...path, index],\r\n      objectsInThisPath\r\n    );\r\n\r\n    transformedValue[index] = recursiveResult.transformedValue;\r\n\r\n    if (isArray(recursiveResult.annotations)) {\r\n      innerAnnotations[index] = recursiveResult.annotations;\r\n    } else if (isPlainObject(recursiveResult.annotations)) {\r\n      forEach(recursiveResult.annotations, (tree, key) => {\r\n        innerAnnotations[escapeKey(index) + '.' + key] = tree;\r\n      });\r\n    }\r\n  });\r\n\r\n  if (isEmptyObject(innerAnnotations)) {\r\n    return {\r\n      transformedValue,\r\n      annotations: !!transformationResult\r\n        ? [transformationResult.type]\r\n        : undefined,\r\n    };\r\n  } else {\r\n    return {\r\n      transformedValue,\r\n      annotations: !!transformationResult\r\n        ? [transformationResult.type, innerAnnotations]\r\n        : innerAnnotations,\r\n    };\r\n  }\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}