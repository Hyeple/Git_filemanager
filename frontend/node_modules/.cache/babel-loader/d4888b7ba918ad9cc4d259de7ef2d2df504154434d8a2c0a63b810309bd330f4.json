{"ast":null,"code":"import _objectSpread from \"C:/Users/parkj/Desktop/nginx-file-browser-master/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"C:/Users/parkj/Desktop/nginx-file-browser-master/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"C:/Users/parkj/Desktop/nginx-file-browser-master/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/parkj/Desktop/nginx-file-browser-master/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { parseFilterArgs, parseQueryArgs, functionalUpdate, noop, hashQueryKey, partialMatchKey, hashQueryKeyByOptions } from './utils.mjs';\nimport { QueryCache } from './queryCache.mjs';\nimport { MutationCache } from './mutationCache.mjs';\nimport { focusManager } from './focusManager.mjs';\nimport { onlineManager } from './onlineManager.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior.mjs';\nimport { defaultLogger } from './logger.mjs';\n\n// CLASS\nvar QueryClient = /*#__PURE__*/function () {\n  function QueryClient() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, QueryClient);\n    this.queryCache = config.queryCache || new QueryCache();\n    this.mutationCache = config.mutationCache || new MutationCache();\n    this.logger = config.logger || defaultLogger;\n    this.defaultOptions = config.defaultOptions || {};\n    this.queryDefaults = [];\n    this.mutationDefaults = [];\n    this.mountCount = 0;\n    if (process.env.NODE_ENV !== 'production' && config.logger) {\n      this.logger.error(\"Passing a custom logger has been deprecated and will be removed in the next major version.\");\n    }\n  }\n  _createClass(QueryClient, [{\n    key: \"mount\",\n    value: function mount() {\n      var _this = this;\n      this.mountCount++;\n      if (this.mountCount !== 1) return;\n      this.unsubscribeFocus = focusManager.subscribe(function () {\n        if (focusManager.isFocused()) {\n          _this.resumePausedMutations();\n          _this.queryCache.onFocus();\n        }\n      });\n      this.unsubscribeOnline = onlineManager.subscribe(function () {\n        if (onlineManager.isOnline()) {\n          _this.resumePausedMutations();\n          _this.queryCache.onOnline();\n        }\n      });\n    }\n  }, {\n    key: \"unmount\",\n    value: function unmount() {\n      var _this$unsubscribeFocu, _this$unsubscribeOnli;\n      this.mountCount--;\n      if (this.mountCount !== 0) return;\n      (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);\n      this.unsubscribeFocus = undefined;\n      (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);\n      this.unsubscribeOnline = undefined;\n    }\n  }, {\n    key: \"isFetching\",\n    value: function isFetching(arg1, arg2) {\n      var _parseFilterArgs = parseFilterArgs(arg1, arg2),\n        _parseFilterArgs2 = _slicedToArray(_parseFilterArgs, 1),\n        filters = _parseFilterArgs2[0];\n      filters.fetchStatus = 'fetching';\n      return this.queryCache.findAll(filters).length;\n    }\n  }, {\n    key: \"isMutating\",\n    value: function isMutating(filters) {\n      return this.mutationCache.findAll(_objectSpread(_objectSpread({}, filters), {}, {\n        fetching: true\n      })).length;\n    }\n  }, {\n    key: \"getQueryData\",\n    value: function getQueryData(queryKey, filters) {\n      var _this$queryCache$find;\n      return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;\n    }\n  }, {\n    key: \"ensureQueryData\",\n    value: function ensureQueryData(arg1, arg2, arg3) {\n      var parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n      var cachedData = this.getQueryData(parsedOptions.queryKey);\n      return cachedData ? Promise.resolve(cachedData) : this.fetchQuery(parsedOptions);\n    }\n  }, {\n    key: \"getQueriesData\",\n    value: function getQueriesData(queryKeyOrFilters) {\n      return this.getQueryCache().findAll(queryKeyOrFilters).map(function (_ref2) {\n        var queryKey = _ref2.queryKey,\n          state = _ref2.state;\n        var data = state.data;\n        return [queryKey, data];\n      });\n    }\n  }, {\n    key: \"setQueryData\",\n    value: function setQueryData(queryKey, updater, options) {\n      var query = this.queryCache.find(queryKey);\n      var prevData = query == null ? void 0 : query.state.data;\n      var data = functionalUpdate(updater, prevData);\n      if (typeof data === 'undefined') {\n        return undefined;\n      }\n      var parsedOptions = parseQueryArgs(queryKey);\n      var defaultedOptions = this.defaultQueryOptions(parsedOptions);\n      return this.queryCache.build(this, defaultedOptions).setData(data, _objectSpread(_objectSpread({}, options), {}, {\n        manual: true\n      }));\n    }\n  }, {\n    key: \"setQueriesData\",\n    value: function setQueriesData(queryKeyOrFilters, updater, options) {\n      var _this2 = this;\n      return notifyManager.batch(function () {\n        return _this2.getQueryCache().findAll(queryKeyOrFilters).map(function (_ref3) {\n          var queryKey = _ref3.queryKey;\n          return [queryKey, _this2.setQueryData(queryKey, updater, options)];\n        });\n      });\n    }\n  }, {\n    key: \"getQueryState\",\n    value: function getQueryState(queryKey, filters) {\n      var _this$queryCache$find2;\n      return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;\n    }\n  }, {\n    key: \"removeQueries\",\n    value: function removeQueries(arg1, arg2) {\n      var _parseFilterArgs3 = parseFilterArgs(arg1, arg2),\n        _parseFilterArgs4 = _slicedToArray(_parseFilterArgs3, 1),\n        filters = _parseFilterArgs4[0];\n      var queryCache = this.queryCache;\n      notifyManager.batch(function () {\n        queryCache.findAll(filters).forEach(function (query) {\n          queryCache.remove(query);\n        });\n      });\n    }\n  }, {\n    key: \"resetQueries\",\n    value: function resetQueries(arg1, arg2, arg3) {\n      var _this3 = this;\n      var _parseFilterArgs5 = parseFilterArgs(arg1, arg2, arg3),\n        _parseFilterArgs6 = _slicedToArray(_parseFilterArgs5, 2),\n        filters = _parseFilterArgs6[0],\n        options = _parseFilterArgs6[1];\n      var queryCache = this.queryCache;\n      var refetchFilters = _objectSpread({\n        type: 'active'\n      }, filters);\n      return notifyManager.batch(function () {\n        queryCache.findAll(filters).forEach(function (query) {\n          query.reset();\n        });\n        return _this3.refetchQueries(refetchFilters, options);\n      });\n    }\n  }, {\n    key: \"cancelQueries\",\n    value: function cancelQueries(arg1, arg2, arg3) {\n      var _this4 = this;\n      var _parseFilterArgs7 = parseFilterArgs(arg1, arg2, arg3),\n        _parseFilterArgs8 = _slicedToArray(_parseFilterArgs7, 2),\n        filters = _parseFilterArgs8[0],\n        _parseFilterArgs8$ = _parseFilterArgs8[1],\n        cancelOptions = _parseFilterArgs8$ === void 0 ? {} : _parseFilterArgs8$;\n      if (typeof cancelOptions.revert === 'undefined') {\n        cancelOptions.revert = true;\n      }\n      var promises = notifyManager.batch(function () {\n        return _this4.queryCache.findAll(filters).map(function (query) {\n          return query.cancel(cancelOptions);\n        });\n      });\n      return Promise.all(promises).then(noop).catch(noop);\n    }\n  }, {\n    key: \"invalidateQueries\",\n    value: function invalidateQueries(arg1, arg2, arg3) {\n      var _this5 = this;\n      var _parseFilterArgs9 = parseFilterArgs(arg1, arg2, arg3),\n        _parseFilterArgs10 = _slicedToArray(_parseFilterArgs9, 2),\n        filters = _parseFilterArgs10[0],\n        options = _parseFilterArgs10[1];\n      return notifyManager.batch(function () {\n        var _ref, _filters$refetchType;\n        _this5.queryCache.findAll(filters).forEach(function (query) {\n          query.invalidate();\n        });\n        if (filters.refetchType === 'none') {\n          return Promise.resolve();\n        }\n        var refetchFilters = _objectSpread(_objectSpread({}, filters), {}, {\n          type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : 'active'\n        });\n        return _this5.refetchQueries(refetchFilters, options);\n      });\n    }\n  }, {\n    key: \"refetchQueries\",\n    value: function refetchQueries(arg1, arg2, arg3) {\n      var _this6 = this;\n      var _parseFilterArgs11 = parseFilterArgs(arg1, arg2, arg3),\n        _parseFilterArgs12 = _slicedToArray(_parseFilterArgs11, 2),\n        filters = _parseFilterArgs12[0],\n        options = _parseFilterArgs12[1];\n      var promises = notifyManager.batch(function () {\n        return _this6.queryCache.findAll(filters).filter(function (query) {\n          return !query.isDisabled();\n        }).map(function (query) {\n          var _options$cancelRefetc;\n          return query.fetch(undefined, _objectSpread(_objectSpread({}, options), {}, {\n            cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,\n            meta: {\n              refetchPage: filters.refetchPage\n            }\n          }));\n        });\n      });\n      var promise = Promise.all(promises).then(noop);\n      if (!(options != null && options.throwOnError)) {\n        promise = promise.catch(noop);\n      }\n      return promise;\n    }\n  }, {\n    key: \"fetchQuery\",\n    value: function fetchQuery(arg1, arg2, arg3) {\n      var parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n      var defaultedOptions = this.defaultQueryOptions(parsedOptions); // https://github.com/tannerlinsley/react-query/issues/652\n\n      if (typeof defaultedOptions.retry === 'undefined') {\n        defaultedOptions.retry = false;\n      }\n      var query = this.queryCache.build(this, defaultedOptions);\n      return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n    }\n  }, {\n    key: \"prefetchQuery\",\n    value: function prefetchQuery(arg1, arg2, arg3) {\n      return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);\n    }\n  }, {\n    key: \"fetchInfiniteQuery\",\n    value: function fetchInfiniteQuery(arg1, arg2, arg3) {\n      var parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n      parsedOptions.behavior = infiniteQueryBehavior();\n      return this.fetchQuery(parsedOptions);\n    }\n  }, {\n    key: \"prefetchInfiniteQuery\",\n    value: function prefetchInfiniteQuery(arg1, arg2, arg3) {\n      return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);\n    }\n  }, {\n    key: \"resumePausedMutations\",\n    value: function resumePausedMutations() {\n      return this.mutationCache.resumePausedMutations();\n    }\n  }, {\n    key: \"getQueryCache\",\n    value: function getQueryCache() {\n      return this.queryCache;\n    }\n  }, {\n    key: \"getMutationCache\",\n    value: function getMutationCache() {\n      return this.mutationCache;\n    }\n  }, {\n    key: \"getLogger\",\n    value: function getLogger() {\n      return this.logger;\n    }\n  }, {\n    key: \"getDefaultOptions\",\n    value: function getDefaultOptions() {\n      return this.defaultOptions;\n    }\n  }, {\n    key: \"setDefaultOptions\",\n    value: function setDefaultOptions(options) {\n      this.defaultOptions = options;\n    }\n  }, {\n    key: \"setQueryDefaults\",\n    value: function setQueryDefaults(queryKey, options) {\n      var result = this.queryDefaults.find(function (x) {\n        return hashQueryKey(queryKey) === hashQueryKey(x.queryKey);\n      });\n      if (result) {\n        result.defaultOptions = options;\n      } else {\n        this.queryDefaults.push({\n          queryKey: queryKey,\n          defaultOptions: options\n        });\n      }\n    }\n  }, {\n    key: \"getQueryDefaults\",\n    value: function getQueryDefaults(queryKey) {\n      if (!queryKey) {\n        return undefined;\n      } // Get the first matching defaults\n\n      var firstMatchingDefaults = this.queryDefaults.find(function (x) {\n        return partialMatchKey(queryKey, x.queryKey);\n      }); // Additional checks and error in dev mode\n\n      if (process.env.NODE_ENV !== 'production') {\n        // Retrieve all matching defaults for the given key\n        var matchingDefaults = this.queryDefaults.filter(function (x) {\n          return partialMatchKey(queryKey, x.queryKey);\n        }); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n        if (matchingDefaults.length > 1) {\n          this.logger.error(\"[QueryClient] Several query defaults match with key '\" + JSON.stringify(queryKey) + \"'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.\");\n        }\n      }\n      return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n    }\n  }, {\n    key: \"setMutationDefaults\",\n    value: function setMutationDefaults(mutationKey, options) {\n      var result = this.mutationDefaults.find(function (x) {\n        return hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey);\n      });\n      if (result) {\n        result.defaultOptions = options;\n      } else {\n        this.mutationDefaults.push({\n          mutationKey: mutationKey,\n          defaultOptions: options\n        });\n      }\n    }\n  }, {\n    key: \"getMutationDefaults\",\n    value: function getMutationDefaults(mutationKey) {\n      if (!mutationKey) {\n        return undefined;\n      } // Get the first matching defaults\n\n      var firstMatchingDefaults = this.mutationDefaults.find(function (x) {\n        return partialMatchKey(mutationKey, x.mutationKey);\n      }); // Additional checks and error in dev mode\n\n      if (process.env.NODE_ENV !== 'production') {\n        // Retrieve all matching defaults for the given key\n        var matchingDefaults = this.mutationDefaults.filter(function (x) {\n          return partialMatchKey(mutationKey, x.mutationKey);\n        }); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n        if (matchingDefaults.length > 1) {\n          this.logger.error(\"[QueryClient] Several mutation defaults match with key '\" + JSON.stringify(mutationKey) + \"'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.\");\n        }\n      }\n      return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n    }\n  }, {\n    key: \"defaultQueryOptions\",\n    value: function defaultQueryOptions(options) {\n      if (options != null && options._defaulted) {\n        return options;\n      }\n      var defaultedOptions = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, this.defaultOptions.queries), this.getQueryDefaults(options == null ? void 0 : options.queryKey)), options), {}, {\n        _defaulted: true\n      });\n      if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n        defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);\n      } // dependent default values\n\n      if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n        defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== 'always';\n      }\n      if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n        defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;\n      }\n      return defaultedOptions;\n    }\n  }, {\n    key: \"defaultMutationOptions\",\n    value: function defaultMutationOptions(options) {\n      if (options != null && options._defaulted) {\n        return options;\n      }\n      return _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, this.defaultOptions.mutations), this.getMutationDefaults(options == null ? void 0 : options.mutationKey)), options), {}, {\n        _defaulted: true\n      });\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.queryCache.clear();\n      this.mutationCache.clear();\n    }\n  }]);\n  return QueryClient;\n}();\nexport { QueryClient };","map":{"version":3,"names":["QueryClient","config","arguments","length","undefined","_classCallCheck","queryCache","QueryCache","mutationCache","MutationCache","logger","defaultLogger","defaultOptions","queryDefaults","mutationDefaults","mountCount","process","env","NODE_ENV","error","_createClass","key","value","mount","_this","unsubscribeFocus","focusManager","subscribe","isFocused","resumePausedMutations","onFocus","unsubscribeOnline","onlineManager","isOnline","onOnline","unmount","_this$unsubscribeFocu","_this$unsubscribeOnli","call","isFetching","arg1","arg2","_parseFilterArgs","parseFilterArgs","_parseFilterArgs2","_slicedToArray","filters","fetchStatus","findAll","isMutating","_objectSpread","fetching","getQueryData","queryKey","_this$queryCache$find","find","state","data","ensureQueryData","arg3","parsedOptions","parseQueryArgs","cachedData","Promise","resolve","fetchQuery","getQueriesData","queryKeyOrFilters","getQueryCache","map","_ref2","setQueryData","updater","options","query","prevData","functionalUpdate","defaultedOptions","defaultQueryOptions","build","setData","manual","setQueriesData","_this2","notifyManager","batch","_ref3","getQueryState","_this$queryCache$find2","removeQueries","_parseFilterArgs3","_parseFilterArgs4","forEach","remove","resetQueries","_this3","_parseFilterArgs5","_parseFilterArgs6","refetchFilters","type","reset","refetchQueries","cancelQueries","_this4","_parseFilterArgs7","_parseFilterArgs8","_parseFilterArgs8$","cancelOptions","revert","promises","cancel","all","then","noop","catch","invalidateQueries","_this5","_parseFilterArgs9","_parseFilterArgs10","_ref","_filters$refetchType","invalidate","refetchType","_this6","_parseFilterArgs11","_parseFilterArgs12","filter","isDisabled","_options$cancelRefetc","fetch","cancelRefetch","meta","refetchPage","promise","throwOnError","retry","isStaleByTime","staleTime","prefetchQuery","fetchInfiniteQuery","behavior","infiniteQueryBehavior","prefetchInfiniteQuery","getMutationCache","getLogger","getDefaultOptions","setDefaultOptions","setQueryDefaults","result","x","hashQueryKey","push","getQueryDefaults","firstMatchingDefaults","partialMatchKey","matchingDefaults","JSON","stringify","setMutationDefaults","mutationKey","getMutationDefaults","_defaulted","queries","queryHash","hashQueryKeyByOptions","refetchOnReconnect","networkMode","useErrorBoundary","suspense","defaultMutationOptions","mutations","clear"],"sources":["C:\\Users\\parkj\\Desktop\\nginx-file-browser-master\\frontend\\node_modules\\@tanstack\\query-core\\src\\queryClient.ts"],"sourcesContent":["import type { QueryFilters, Updater, MutationFilters } from './utils'\nimport {\n  hashQueryKey,\n  noop,\n  parseFilterArgs,\n  parseQueryArgs,\n  partialMatchKey,\n  hashQueryKeyByOptions,\n  functionalUpdate,\n} from './utils'\nimport type {\n  QueryClientConfig,\n  DefaultOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationKey,\n  MutationObserverOptions,\n  MutationOptions,\n  QueryFunction,\n  QueryKey,\n  QueryObserverOptions,\n  QueryOptions,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  ResetQueryFilters,\n  SetDataOptions,\n  WithRequired,\n} from './types'\nimport type { QueryState } from './query'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { notifyManager } from './notifyManager'\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior'\nimport type { CancelOptions, DefaultedQueryObserverOptions } from './types'\nimport type { Logger } from './logger'\nimport { defaultLogger } from './logger'\n\n// TYPES\n\ninterface QueryDefaults {\n  queryKey: QueryKey\n  defaultOptions: QueryOptions<any, any, any>\n}\n\ninterface MutationDefaults {\n  mutationKey: MutationKey\n  defaultOptions: MutationOptions<any, any, any, any>\n}\n\n// CLASS\n\nexport class QueryClient {\n  private queryCache: QueryCache\n  private mutationCache: MutationCache\n  private logger: Logger\n  private defaultOptions: DefaultOptions\n  private queryDefaults: QueryDefaults[]\n  private mutationDefaults: MutationDefaults[]\n  private mountCount: number\n  private unsubscribeFocus?: () => void\n  private unsubscribeOnline?: () => void\n\n  constructor(config: QueryClientConfig = {}) {\n    this.queryCache = config.queryCache || new QueryCache()\n    this.mutationCache = config.mutationCache || new MutationCache()\n    this.logger = config.logger || defaultLogger\n    this.defaultOptions = config.defaultOptions || {}\n    this.queryDefaults = []\n    this.mutationDefaults = []\n    this.mountCount = 0\n\n    if (process.env.NODE_ENV !== 'production' && config.logger) {\n      this.logger.error(\n        `Passing a custom logger has been deprecated and will be removed in the next major version.`,\n      )\n    }\n  }\n\n  mount(): void {\n    this.mountCount++\n    if (this.mountCount !== 1) return\n\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations()\n        this.queryCache.onFocus()\n      }\n    })\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations()\n        this.queryCache.onOnline()\n      }\n    })\n  }\n\n  unmount(): void {\n    this.mountCount--\n    if (this.mountCount !== 0) return\n\n    this.unsubscribeFocus?.()\n    this.unsubscribeFocus = undefined\n\n    this.unsubscribeOnline?.()\n    this.unsubscribeOnline = undefined\n  }\n\n  isFetching(filters?: QueryFilters): number\n  isFetching(queryKey?: QueryKey, filters?: QueryFilters): number\n  isFetching(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): number {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    filters.fetchStatus = 'fetching'\n    return this.queryCache.findAll(filters).length\n  }\n\n  isMutating(filters?: MutationFilters): number {\n    return this.mutationCache.findAll({ ...filters, fetching: true }).length\n  }\n\n  getQueryData<TQueryFnData = unknown>(\n    queryKey: QueryKey,\n    filters?: QueryFilters,\n  ): TQueryFnData | undefined {\n    return this.queryCache.find<TQueryFnData>(queryKey, filters)?.state.data\n  }\n\n  ensureQueryData<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: WithRequired<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n  ): Promise<TData>\n  ensureQueryData<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: Omit<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n  ): Promise<TData>\n  ensureQueryData<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: Omit<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey' | 'queryFn'\n    >,\n  ): Promise<TData>\n  ensureQueryData<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | TQueryKey\n      | WithRequired<\n          FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n          'queryKey'\n        >,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    const cachedData = this.getQueryData<TData>(parsedOptions.queryKey!)\n\n    return cachedData\n      ? Promise.resolve(cachedData)\n      : this.fetchQuery(parsedOptions)\n  }\n\n  getQueriesData<TQueryFnData = unknown>(\n    queryKey: QueryKey,\n  ): [QueryKey, TQueryFnData | undefined][]\n  getQueriesData<TQueryFnData = unknown>(\n    filters: QueryFilters,\n  ): [QueryKey, TQueryFnData | undefined][]\n  getQueriesData<TQueryFnData = unknown>(\n    queryKeyOrFilters: QueryKey | QueryFilters,\n  ): [QueryKey, TQueryFnData | undefined][] {\n    return this.getQueryCache()\n      .findAll(queryKeyOrFilters)\n      .map(({ queryKey, state }) => {\n        const data = state.data as TQueryFnData | undefined\n        return [queryKey, data]\n      })\n  }\n\n  setQueryData<TQueryFnData>(\n    queryKey: QueryKey,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): TQueryFnData | undefined {\n    const query = this.queryCache.find<TQueryFnData>(queryKey)\n    const prevData = query?.state.data\n    const data = functionalUpdate(updater, prevData)\n\n    if (typeof data === 'undefined') {\n      return undefined\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n    return this.queryCache\n      .build(this, defaultedOptions)\n      .setData(data, { ...options, manual: true })\n  }\n\n  setQueriesData<TQueryFnData>(\n    queryKey: QueryKey,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][]\n\n  setQueriesData<TQueryFnData>(\n    filters: QueryFilters,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][]\n\n  setQueriesData<TQueryFnData>(\n    queryKeyOrFilters: QueryKey | QueryFilters,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][] {\n    return notifyManager.batch(() =>\n      this.getQueryCache()\n        .findAll(queryKeyOrFilters)\n        .map(({ queryKey }) => [\n          queryKey,\n          this.setQueryData<TQueryFnData>(queryKey, updater, options),\n        ]),\n    )\n  }\n\n  getQueryState<TQueryFnData = unknown, TError = undefined>(\n    queryKey: QueryKey,\n    filters?: QueryFilters,\n  ): QueryState<TQueryFnData, TError> | undefined {\n    return this.queryCache.find<TQueryFnData, TError>(queryKey, filters)?.state\n  }\n\n  removeQueries(filters?: QueryFilters): void\n  removeQueries(queryKey?: QueryKey, filters?: QueryFilters): void\n  removeQueries(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): void {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    const queryCache = this.queryCache\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query)\n      })\n    })\n  }\n\n  resetQueries<TPageData = unknown>(\n    filters?: ResetQueryFilters<TPageData>,\n    options?: ResetOptions,\n  ): Promise<void>\n  resetQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: ResetQueryFilters<TPageData>,\n    options?: ResetOptions,\n  ): Promise<void>\n  resetQueries(\n    arg1?: QueryKey | ResetQueryFilters,\n    arg2?: ResetQueryFilters | ResetOptions,\n    arg3?: ResetOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n    const queryCache = this.queryCache\n\n    const refetchFilters: RefetchQueryFilters = {\n      type: 'active',\n      ...filters,\n    }\n\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset()\n      })\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  cancelQueries(filters?: QueryFilters, options?: CancelOptions): Promise<void>\n  cancelQueries(\n    queryKey?: QueryKey,\n    filters?: QueryFilters,\n    options?: CancelOptions,\n  ): Promise<void>\n  cancelQueries(\n    arg1?: QueryKey | QueryFilters,\n    arg2?: QueryFilters | CancelOptions,\n    arg3?: CancelOptions,\n  ): Promise<void> {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3)\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true\n    }\n\n    const promises = notifyManager.batch(() =>\n      this.queryCache\n        .findAll(filters)\n        .map((query) => query.cancel(cancelOptions)),\n    )\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  invalidateQueries<TPageData = unknown>(\n    filters?: InvalidateQueryFilters<TPageData>,\n    options?: InvalidateOptions,\n  ): Promise<void>\n  invalidateQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: InvalidateQueryFilters<TPageData>,\n    options?: InvalidateOptions,\n  ): Promise<void>\n  invalidateQueries(\n    arg1?: QueryKey | InvalidateQueryFilters,\n    arg2?: InvalidateQueryFilters | InvalidateOptions,\n    arg3?: InvalidateOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    return notifyManager.batch(() => {\n      this.queryCache.findAll(filters).forEach((query) => {\n        query.invalidate()\n      })\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve()\n      }\n      const refetchFilters: RefetchQueryFilters = {\n        ...filters,\n        type: filters.refetchType ?? filters.type ?? 'active',\n      }\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  refetchQueries<TPageData = unknown>(\n    filters?: RefetchQueryFilters<TPageData>,\n    options?: RefetchOptions,\n  ): Promise<void>\n  refetchQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: RefetchQueryFilters<TPageData>,\n    options?: RefetchOptions,\n  ): Promise<void>\n  refetchQueries(\n    arg1?: QueryKey | RefetchQueryFilters,\n    arg2?: RefetchQueryFilters | RefetchOptions,\n    arg3?: RefetchOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    const promises = notifyManager.batch(() =>\n      this.queryCache\n        .findAll(filters)\n        .filter((query) => !query.isDisabled())\n        .map((query) =>\n          query.fetch(undefined, {\n            ...options,\n            cancelRefetch: options?.cancelRefetch ?? true,\n            meta: { refetchPage: filters.refetchPage },\n          }),\n        ),\n    )\n\n    let promise = Promise.all(promises).then(noop)\n\n    if (!options?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: TQueryKey | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions)\n\n    return query.isStaleByTime(defaultedOptions.staleTime)\n      ? query.fetch(defaultedOptions)\n      : Promise.resolve(query.state.data as TData)\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: TQueryKey | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | TQueryKey\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    parsedOptions.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData\n    >()\n    return this.fetchQuery(parsedOptions)\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | TQueryKey\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchInfiniteQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    return this.mutationCache.resumePausedMutations()\n  }\n\n  getQueryCache(): QueryCache {\n    return this.queryCache\n  }\n\n  getMutationCache(): MutationCache {\n    return this.mutationCache\n  }\n\n  getLogger(): Logger {\n    return this.logger\n  }\n\n  getDefaultOptions(): DefaultOptions {\n    return this.defaultOptions\n  }\n\n  setDefaultOptions(options: DefaultOptions): void {\n    this.defaultOptions = options\n  }\n\n  setQueryDefaults(\n    queryKey: QueryKey,\n    options: QueryObserverOptions<unknown, any, any, any>,\n  ): void {\n    const result = this.queryDefaults.find(\n      (x) => hashQueryKey(queryKey) === hashQueryKey(x.queryKey),\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.queryDefaults.push({ queryKey, defaultOptions: options })\n    }\n  }\n\n  getQueryDefaults(\n    queryKey?: QueryKey,\n  ): QueryObserverOptions<any, any, any, any, any> | undefined {\n    if (!queryKey) {\n      return undefined\n    }\n\n    // Get the first matching defaults\n    const firstMatchingDefaults = this.queryDefaults.find((x) =>\n      partialMatchKey(queryKey, x.queryKey),\n    )\n\n    // Additional checks and error in dev mode\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter((x) =>\n        partialMatchKey(queryKey, x.queryKey),\n      )\n      // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\n          `[QueryClient] Several query defaults match with key '${JSON.stringify(\n            queryKey,\n          )}'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.`,\n        )\n      }\n    }\n\n    return firstMatchingDefaults?.defaultOptions\n  }\n\n  setMutationDefaults(\n    mutationKey: MutationKey,\n    options: MutationObserverOptions<any, any, any, any>,\n  ): void {\n    const result = this.mutationDefaults.find(\n      (x) => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey),\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.mutationDefaults.push({ mutationKey, defaultOptions: options })\n    }\n  }\n\n  getMutationDefaults(\n    mutationKey?: MutationKey,\n  ): MutationObserverOptions<any, any, any, any> | undefined {\n    if (!mutationKey) {\n      return undefined\n    }\n\n    // Get the first matching defaults\n    const firstMatchingDefaults = this.mutationDefaults.find((x) =>\n      partialMatchKey(mutationKey, x.mutationKey),\n    )\n\n    // Additional checks and error in dev mode\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter((x) =>\n        partialMatchKey(mutationKey, x.mutationKey),\n      )\n      // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\n          `[QueryClient] Several mutation defaults match with key '${JSON.stringify(\n            mutationKey,\n          )}'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.`,\n        )\n      }\n    }\n\n    return firstMatchingDefaults?.defaultOptions\n  }\n\n  defaultQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey extends QueryKey,\n  >(\n    options?:\n      | QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>\n      | DefaultedQueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey\n        >,\n  ): DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {\n    if (options?._defaulted) {\n      return options as DefaultedQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        TQueryKey\n      >\n    }\n\n    const defaultedOptions = {\n      ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options?.queryKey),\n      ...options,\n      _defaulted: true,\n    }\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions,\n      )\n    }\n\n    // dependent default values\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect =\n        defaultedOptions.networkMode !== 'always'\n    }\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense\n    }\n\n    return defaultedOptions as DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >\n  }\n\n  defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(\n    options?: T,\n  ): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options?.mutationKey),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  clear(): void {\n    this.queryCache.clear()\n    this.mutationCache.clear()\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}