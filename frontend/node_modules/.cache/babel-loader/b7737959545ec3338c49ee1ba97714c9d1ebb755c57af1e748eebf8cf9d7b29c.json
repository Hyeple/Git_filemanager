{"ast":null,"code":"'use client';\n\nimport _slicedToArray from \"C:/Users/parkj/Desktop/nginx-file-browser-master/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport * as React from 'react';\nimport { useSyncExternalStore } from './useSyncExternalStore.mjs';\nimport { QueriesObserver, notifyManager } from '@tanstack/query-core';\nimport { useQueryClient } from './QueryClientProvider.mjs';\nimport { useIsRestoring } from './isRestoring.mjs';\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary.mjs';\nimport { ensurePreventErrorBoundaryRetry, useClearResetErrorBoundary, getHasError } from './errorBoundaryUtils.mjs';\nimport { ensureStaleTime, shouldSuspend, fetchOptimistic, willFetch } from './suspense.mjs';\n\n// - `context` is omitted as it is passed as a root-level option to `useQueries` instead.\n\nfunction useQueries(_ref) {\n  var queries = _ref.queries,\n    context = _ref.context;\n  var queryClient = useQueryClient({\n    context: context\n  });\n  var isRestoring = useIsRestoring();\n  var errorResetBoundary = useQueryErrorResetBoundary();\n  var defaultedQueries = React.useMemo(function () {\n    return queries.map(function (options) {\n      var defaultedOptions = queryClient.defaultQueryOptions(options); // Make sure the results are already in fetching state before subscribing or updating options\n\n      defaultedOptions._optimisticResults = isRestoring ? 'isRestoring' : 'optimistic';\n      return defaultedOptions;\n    });\n  }, [queries, queryClient, isRestoring]);\n  defaultedQueries.forEach(function (query) {\n    ensureStaleTime(query);\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary);\n  });\n  useClearResetErrorBoundary(errorResetBoundary);\n  var _React$useState = React.useState(function () {\n      return new QueriesObserver(queryClient, defaultedQueries);\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 1),\n    observer = _React$useState2[0];\n  var optimisticResult = observer.getOptimisticResult(defaultedQueries);\n  useSyncExternalStore(React.useCallback(function (onStoreChange) {\n    return isRestoring ? function () {\n      return undefined;\n    } : observer.subscribe(notifyManager.batchCalls(onStoreChange));\n  }, [observer, isRestoring]), function () {\n    return observer.getCurrentResult();\n  }, function () {\n    return observer.getCurrentResult();\n  });\n  React.useEffect(function () {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(defaultedQueries, {\n      listeners: false\n    });\n  }, [defaultedQueries, observer]);\n  var shouldAtLeastOneSuspend = optimisticResult.some(function (result, index) {\n    return shouldSuspend(defaultedQueries[index], result, isRestoring);\n  });\n  var suspensePromises = shouldAtLeastOneSuspend ? optimisticResult.flatMap(function (result, index) {\n    var options = defaultedQueries[index];\n    var queryObserver = observer.getObservers()[index];\n    if (options && queryObserver) {\n      if (shouldSuspend(options, result, isRestoring)) {\n        return fetchOptimistic(options, queryObserver, errorResetBoundary);\n      } else if (willFetch(result, isRestoring)) {\n        void fetchOptimistic(options, queryObserver, errorResetBoundary);\n      }\n    }\n    return [];\n  }) : [];\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises);\n  }\n  var observerQueries = observer.getQueries();\n  var firstSingleResultWhichShouldThrow = optimisticResult.find(function (result, index) {\n    var _defaultedQueries$ind, _defaultedQueries$ind2;\n    return getHasError({\n      result: result,\n      errorResetBoundary: errorResetBoundary,\n      useErrorBoundary: (_defaultedQueries$ind = (_defaultedQueries$ind2 = defaultedQueries[index]) == null ? void 0 : _defaultedQueries$ind2.useErrorBoundary) != null ? _defaultedQueries$ind : false,\n      query: observerQueries[index]\n    });\n  });\n  if (firstSingleResultWhichShouldThrow != null && firstSingleResultWhichShouldThrow.error) {\n    throw firstSingleResultWhichShouldThrow.error;\n  }\n  return optimisticResult;\n}\nexport { useQueries };","map":{"version":3,"names":["useQueries","_ref","context","defaultedQueries","React","useMemo","queries","map","options","defaultedOptions","_optimisticResults","isRestoring","forEach","query","ensurePreventErrorBoundaryRetry","errorResetBoundary","_React$useState","useState","QueriesObserver","queryClient","_React$useState2","_slicedToArray","observer","optimisticResult","getOptimisticResult","useSyncExternalStore","useCallback","onStoreChange","undefined","subscribe","notifyManager","batchCalls","getCurrentResult","setQueries","listeners","suspensePromises","shouldAtLeastOneSuspend","flatMap","result","index","queryObserver","getObservers","fetchOptimistic","length","Promise","all","observerQueries","getQueries","_defaultedQueries$ind","_defaultedQueries$ind2","getHasError","firstSingleResultWhichShouldThrow","error"],"sources":["C:\\Users\\parkj\\Desktop\\nginx-file-browser-master\\frontend\\node_modules\\@tanstack\\react-query\\src\\useQueries.ts"],"sourcesContent":["'use client'\nimport * as React from 'react'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport type { QueryKey, QueryFunction } from '@tanstack/query-core'\nimport { notifyManager, QueriesObserver } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type { UseQueryOptions, UseQueryResult } from './types'\nimport { useIsRestoring } from './isRestoring'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport {\n  ensureStaleTime,\n  shouldSuspend,\n  fetchOptimistic,\n  willFetch,\n} from './suspense'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// - `context` is omitted as it is passed as a root-level option to `useQueries` instead.\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = Omit<UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>, 'context'>\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n    T extends [infer TQueryFnData, infer TError, infer TData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData>\n    : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, unknown, TData, TQueryKey>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey> }\n    ? UseQueryOptionsForUseQueries<\n        TQueryFnData,\n        unknown,\n        TQueryFnData,\n        TQueryKey\n      >\n    : // Fallback\n      UseQueryOptionsForUseQueries\n\ntype GetResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? UseQueryResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryResult<TData, TError>\n    : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n    T extends [any, infer TError, infer TData]\n    ? UseQueryResult<TData, TError>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryResult<TQueryFnData>\n    : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<unknown, any>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryResult<TData>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, any> }\n    ? UseQueryResult<TQueryFnData>\n    : // Fallback\n      UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryOptionsForUseQueries[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetOptions<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesOptions<[...Tail], [...Result, GetOptions<Head>], [...Depth, 1]>\n  : unknown[] extends T\n  ? T\n  : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n  // use this to infer the param types in the case of Array.map() argument\n  T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      infer TQueryKey\n    >[]\n  ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData, TQueryKey>[]\n  : // Fallback\n    UseQueryOptionsForUseQueries[]\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryResult[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetResults<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesResults<[...Tail], [...Result, GetResults<Head>], [...Depth, 1]>\n  : T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      any\n    >[]\n  ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n    UseQueryResult<unknown extends TData ? TQueryFnData : TData, TError>[]\n  : // Fallback\n    UseQueryResult[]\n\nexport function useQueries<T extends any[]>({\n  queries,\n  context,\n}: {\n  queries: readonly [...QueriesOptions<T>]\n  context?: UseQueryOptions['context']\n}): QueriesResults<T> {\n  const queryClient = useQueryClient({ context })\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((options) => {\n        const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, queryClient, isRestoring],\n  )\n\n  defaultedQueries.forEach((query) => {\n    ensureStaleTime(query)\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary)\n  })\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () => new QueriesObserver(queryClient, defaultedQueries),\n  )\n\n  const optimisticResult = observer.getOptimisticResult(defaultedQueries)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(defaultedQueries, { listeners: false })\n  }, [defaultedQueries, observer])\n\n  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) =>\n    shouldSuspend(defaultedQueries[index], result, isRestoring),\n  )\n\n  const suspensePromises = shouldAtLeastOneSuspend\n    ? optimisticResult.flatMap((result, index) => {\n        const options = defaultedQueries[index]\n        const queryObserver = observer.getObservers()[index]\n\n        if (options && queryObserver) {\n          if (shouldSuspend(options, result, isRestoring)) {\n            return fetchOptimistic(options, queryObserver, errorResetBoundary)\n          } else if (willFetch(result, isRestoring)) {\n            void fetchOptimistic(options, queryObserver, errorResetBoundary)\n          }\n        }\n        return []\n      })\n    : []\n\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises)\n  }\n  const observerQueries = observer.getQueries()\n  const firstSingleResultWhichShouldThrow = optimisticResult.find(\n    (result, index) =>\n      getHasError({\n        result,\n        errorResetBoundary,\n        useErrorBoundary: defaultedQueries[index]?.useErrorBoundary ?? false,\n        query: observerQueries[index]!,\n      }),\n  )\n\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error\n  }\n\n  return optimisticResult as QueriesResults<T>\n}\n"],"mappings":";;;;;;;;;;;;AAuBA;;AA+HO,SAAAA,WAAAC,IAAA,EAAqC;EAAA,I;IAE1CC,OAAA,GAAAD,IAAA,CAAAC,OAAA;;IAKqCA,OAAA,EAAAA;EAAF;;;EAInC,IAAAC,gBAAA,GAAAC,KAAA,CAAAC,OAAA;IAAA,OAAAC,OAAA,CAAAC,GAAA,WAAAC,OAAA;;;MAMMC,gBAAA,CAAAC,kBAAA,GAAAC,WAAA;MAIA,OAAAF,gBAAA;;;EAKNN,gBAAA,CAAAS,OAAA,WAAAC,KAAA;;IAEEC,+BAAA,CAAAD,KAAA,EAAAE,kBAAA;;;EAKF,IAAAC,eAAA,GAAAZ,KAAA,CAAAa,QAAA;MAAA,WAAAC,eAAA,CAAAC,WAAA,EAAAhB,gBAAA;IAAA;IAAAiB,gBAAA,GAAAC,cAAA,CAAAL,eAAA;IAAAM,QAAA,GAAAF,gBAAA;EAIA,IAAAG,gBAAA,GAAAD,QAAA,CAAAE,mBAAA,CAAArB,gBAAA;EAEAsB,oBAAA,CAAArB,KAAA,CAAAsB,WAAA,WAAAC,aAAA;IAAA,OAAAhB,WAAA;MAAA,OAAAiB,SAAA;IAAA,IAAAN,QAAA,CAAAO,SAAA,CAAAC,aAAA,CAAAC,UAAA,CAAAJ,aAAA;EAAA,IAAAL,QAAA,EAAAX,WAAA;IAAA,OAAAW,QAAA,CAAAU,gBAAA;EAAA;IAAA,OAAAV,QAAA,CAAAU,gBAAA;EAAA;;IAaE;IACA;IACAV,QAAA,CAAAW,UAAA,CAAA9B,gBAAA;MAAwC+B,SAAA;;EACzC,IAAA/B,gBAAA,EAAAmB,QAAA;;;;EAMD,IAAAa,gBAAA,GAAAC,uBAAA,GAAAb,gBAAA,CAAAc,OAAA,WAAAC,MAAA,EAAAC,KAAA;IAEM,IAAA/B,OAAA,GAAAL,gBAAA,CAAAoC,KAAA;IACA,IAAAC,aAAA,GAAAlB,QAAA,CAAAmB,YAAA,GAAAF,KAAA;;;QAII,OAAAG,eAAA,CAAAlC,OAAA,EAAAgC,aAAA,EAAAzB,kBAAA;;QAEA,KAAA2B,eAAA,CAAAlC,OAAA,EAAAgC,aAAA,EAAAzB,kBAAA;MACD;IACF;IACD;;EAIN,IAAAoB,gBAAA,CAAAQ,MAAA;IACE,MAAAC,OAAA,CAAAC,GAAA,CAAAV,gBAAA;EACD;EACD,IAAAW,eAAA,GAAAxB,QAAA,CAAAyB,UAAA;;IAEE,IAAAC,qBAAA,EAAAC,sBAAA;IAAA,OAAAC,WAAA;;;;;IACc;EADd;EASF,IAAAC,iCAAA,YAAAA,iCAAA,CAAAC,KAAA;;EAEC;EAED,OAAA7B,gBAAA;AACD"},"metadata":{},"sourceType":"module","externalDependencies":[]}