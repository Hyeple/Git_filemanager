{"ast":null,"code":"import _createClass from \"C:/Users/parkj/Desktop/nginx-file-browser-master/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/parkj/Desktop/nginx-file-browser-master/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport { focusManager } from './focusManager.mjs';\nimport { onlineManager } from './onlineManager.mjs';\nimport { sleep } from './utils.mjs';\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * Math.pow(2, failureCount), 30000);\n}\nfunction canFetch(networkMode) {\n  return (networkMode != null ? networkMode : 'online') === 'online' ? onlineManager.isOnline() : true;\n}\nvar CancelledError = /*#__PURE__*/_createClass(function CancelledError(options) {\n  _classCallCheck(this, CancelledError);\n  this.revert = options == null ? void 0 : options.revert;\n  this.silent = options == null ? void 0 : options.silent;\n});\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  var isRetryCancelled = false;\n  var failureCount = 0;\n  var isResolved = false;\n  var continueFn;\n  var promiseResolve;\n  var promiseReject;\n  var promise = new Promise(function (outerResolve, outerReject) {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n  var cancel = function cancel(cancelOptions) {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort == null ? void 0 : config.abort();\n    }\n  };\n  var cancelRetry = function cancelRetry() {\n    isRetryCancelled = true;\n  };\n  var continueRetry = function continueRetry() {\n    isRetryCancelled = false;\n  };\n  var shouldPause = function shouldPause() {\n    return !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();\n  };\n  var resolve = function resolve(value) {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n  var reject = function reject(value) {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n  var pause = function pause() {\n    return new Promise(function (continueResolve) {\n      continueFn = function continueFn(value) {\n        var canContinue = isResolved || !shouldPause();\n        if (canContinue) {\n          continueResolve(value);\n        }\n        return canContinue;\n      };\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(function () {\n      continueFn = undefined;\n      if (!isResolved) {\n        config.onContinue == null ? void 0 : config.onContinue();\n      }\n    });\n  }; // Create loop function\n\n  var run = function run() {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return;\n    }\n    var promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n    Promise.resolve(promiseOrValue).then(resolve).catch(function (error) {\n      var _config$retry, _config$retryDelay;\n\n      // Stop if the fetch is already resolved\n      if (isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n      var retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      var retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      var delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;\n      var shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n      if (isRetryCancelled || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n      failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(function () {\n        if (shouldPause()) {\n          return pause();\n        }\n        return;\n      }).then(function () {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n  return {\n    promise: promise,\n    cancel: cancel,\n    continue: function _continue() {\n      var didContinue = continueFn == null ? void 0 : continueFn();\n      return didContinue ? promise : Promise.resolve();\n    },\n    cancelRetry: cancelRetry,\n    continueRetry: continueRetry\n  };\n}\nexport { CancelledError, canFetch, createRetryer, isCancelledError };","map":{"version":3,"names":["defaultRetryDelay","failureCount","Math","min","pow","canFetch","networkMode","onlineManager","isOnline","CancelledError","_createClass","options","_classCallCheck","revert","silent","isCancelledError","value","createRetryer","config","isRetryCancelled","isResolved","continueFn","promiseResolve","promiseReject","promise","Promise","outerResolve","outerReject","cancel","cancelOptions","reject","abort","cancelRetry","continueRetry","shouldPause","focusManager","isFocused","resolve","onSuccess","onError","pause","continueResolve","canContinue","onPause","then","undefined","onContinue","run","promiseOrValue","fn","error","catch","_config$retry","_config$retryDelay","retry","retryDelay","delay","shouldRetry","onFail","sleep","continue","_continue","didContinue"],"sources":["C:\\Users\\parkj\\Desktop\\nginx-file-browser-master\\frontend\\node_modules\\@tanstack\\query-core\\src\\retryer.ts"],"sourcesContent":["import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { sleep } from './utils'\nimport type { CancelOptions, NetworkMode } from './types'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = unknown> {\n  fn: () => TData | Promise<TData>\n  abort?: () => void\n  onError?: (error: TError) => void\n  onSuccess?: (data: TData) => void\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode: NetworkMode | undefined\n}\n\nexport interface Retryer<TData = unknown> {\n  promise: Promise<TData>\n  cancel: (cancelOptions?: CancelOptions) => void\n  continue: () => Promise<unknown>\n  cancelRetry: () => void\n  continueRetry: () => void\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError> = (\n  failureCount: number,\n  error: TError,\n) => boolean\n\nexport type RetryDelayValue<TError> = number | RetryDelayFunction<TError>\n\ntype RetryDelayFunction<TError = unknown> = (\n  failureCount: number,\n  error: TError,\n) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\nexport function canFetch(networkMode: NetworkMode | undefined): boolean {\n  return (networkMode ?? 'online') === 'online'\n    ? onlineManager.isOnline()\n    : true\n}\n\nexport class CancelledError {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function createRetryer<TData = unknown, TError = unknown>(\n  config: RetryerConfig<TData, TError>,\n): Retryer<TData> {\n  let isRetryCancelled = false\n  let failureCount = 0\n  let isResolved = false\n  let continueFn: ((value?: unknown) => boolean) | undefined\n  let promiseResolve: (data: TData) => void\n  let promiseReject: (error: TError) => void\n\n  const promise = new Promise<TData>((outerResolve, outerReject) => {\n    promiseResolve = outerResolve\n    promiseReject = outerReject\n  })\n\n  const cancel = (cancelOptions?: CancelOptions): void => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions))\n\n      config.abort?.()\n    }\n  }\n  const cancelRetry = () => {\n    isRetryCancelled = true\n  }\n\n  const continueRetry = () => {\n    isRetryCancelled = false\n  }\n\n  const shouldPause = () =>\n    !focusManager.isFocused() ||\n    (config.networkMode !== 'always' && !onlineManager.isOnline())\n\n  const resolve = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onSuccess?.(value)\n      continueFn?.()\n      promiseResolve(value)\n    }\n  }\n\n  const reject = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onError?.(value)\n      continueFn?.()\n      promiseReject(value)\n    }\n  }\n\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        const canContinue = isResolved || !shouldPause()\n        if (canContinue) {\n          continueResolve(value)\n        }\n        return canContinue\n      }\n      config.onPause?.()\n    }).then(() => {\n      continueFn = undefined\n      if (!isResolved) {\n        config.onContinue?.()\n      }\n    })\n  }\n\n  // Create loop function\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return\n    }\n\n    let promiseOrValue: any\n\n    // Execute query\n    try {\n      promiseOrValue = config.fn()\n    } catch (error) {\n      promiseOrValue = Promise.reject(error)\n    }\n\n    Promise.resolve(promiseOrValue)\n      .then(resolve)\n      .catch((error) => {\n        // Stop if the fetch is already resolved\n        if (isResolved) {\n          return\n        }\n\n        // Do we need to retry the request?\n        const retry = config.retry ?? 3\n        const retryDelay = config.retryDelay ?? defaultRetryDelay\n        const delay =\n          typeof retryDelay === 'function'\n            ? retryDelay(failureCount, error)\n            : retryDelay\n        const shouldRetry =\n          retry === true ||\n          (typeof retry === 'number' && failureCount < retry) ||\n          (typeof retry === 'function' && retry(failureCount, error))\n\n        if (isRetryCancelled || !shouldRetry) {\n          // We are done if the query does not need to be retried\n          reject(error)\n          return\n        }\n\n        failureCount++\n\n        // Notify on fail\n        config.onFail?.(failureCount, error)\n\n        // Delay\n        sleep(delay)\n          // Pause if the document is not visible or when the device is offline\n          .then(() => {\n            if (shouldPause()) {\n              return pause()\n            }\n            return\n          })\n          .then(() => {\n            if (isRetryCancelled) {\n              reject(error)\n            } else {\n              run()\n            }\n          })\n      })\n  }\n\n  // Start loop\n  if (canFetch(config.networkMode)) {\n    run()\n  } else {\n    pause().then(run)\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      const didContinue = continueFn?.()\n      return didContinue ? promise : Promise.resolve()\n    },\n    cancelRetry,\n    continueRetry,\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}