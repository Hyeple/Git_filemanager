{"ast":null,"code":"import _slicedToArray from \"C:/Users/parkj/Desktop/OSS/Git_filemanager/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport toArray from \"rc-util/es/Children/toArray\";\nimport useIsomorphicLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nimport * as React from 'react';\nfunction cuttable(node) {\n  var type = typeof node;\n  return type === 'string' || type === 'number';\n}\nfunction getNodesLen(nodeList) {\n  var totalLen = 0;\n  nodeList.forEach(function (node) {\n    if (cuttable(node)) {\n      totalLen += String(node).length;\n    } else {\n      totalLen += 1;\n    }\n  });\n  return totalLen;\n}\nfunction sliceNodes(nodeList, len) {\n  var currLen = 0;\n  var currentNodeList = [];\n  for (var i = 0; i < nodeList.length; i += 1) {\n    // Match to return\n    if (currLen === len) {\n      return currentNodeList;\n    }\n    var node = nodeList[i];\n    var canCut = cuttable(node);\n    var nodeLen = canCut ? String(node).length : 1;\n    var nextLen = currLen + nodeLen;\n    // Exceed but current not which means we need cut this\n    // This will not happen on validate ReactElement\n    if (nextLen > len) {\n      var restLen = len - currLen;\n      currentNodeList.push(String(node).slice(0, restLen));\n      return currentNodeList;\n    }\n    currentNodeList.push(node);\n    currLen = nextLen;\n  }\n  return nodeList;\n}\nvar NONE = 0;\nvar PREPARE = 1;\nvar WALKING = 2;\nvar DONE_WITH_ELLIPSIS = 3;\nvar DONE_WITHOUT_ELLIPSIS = 4;\nvar Ellipsis = function Ellipsis(_ref) {\n  var enabledMeasure = _ref.enabledMeasure,\n    children = _ref.children,\n    text = _ref.text,\n    width = _ref.width,\n    fontSize = _ref.fontSize,\n    rows = _ref.rows,\n    onEllipsis = _ref.onEllipsis;\n  var _React$useState = React.useState([0, 0, 0]),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    _React$useState2$ = _slicedToArray(_React$useState2[0], 3),\n    startLen = _React$useState2$[0],\n    midLen = _React$useState2$[1],\n    endLen = _React$useState2$[2],\n    setCutLength = _React$useState2[1];\n  var _React$useState3 = React.useState(NONE),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    walkingState = _React$useState4[0],\n    setWalkingState = _React$useState4[1];\n  var _React$useState5 = React.useState(0),\n    _React$useState6 = _slicedToArray(_React$useState5, 2),\n    singleRowHeight = _React$useState6[0],\n    setSingleRowHeight = _React$useState6[1];\n  var singleRowRef = React.useRef(null);\n  var midRowRef = React.useRef(null);\n  var nodeList = React.useMemo(function () {\n    return toArray(text);\n  }, [text]);\n  var totalLen = React.useMemo(function () {\n    return getNodesLen(nodeList);\n  }, [nodeList]);\n  var mergedChildren = React.useMemo(function () {\n    if (!enabledMeasure || walkingState !== DONE_WITH_ELLIPSIS) {\n      return children(nodeList, false);\n    }\n    return children(sliceNodes(nodeList, midLen), midLen < totalLen);\n  }, [enabledMeasure, walkingState, children, nodeList, midLen, totalLen]);\n  // ======================== Walk ========================\n  useIsomorphicLayoutEffect(function () {\n    if (enabledMeasure && width && fontSize && totalLen) {\n      setWalkingState(PREPARE);\n      setCutLength([0, Math.ceil(totalLen / 2), totalLen]);\n    }\n  }, [enabledMeasure, width, fontSize, text, totalLen, rows]);\n  useIsomorphicLayoutEffect(function () {\n    var _a;\n    if (walkingState === PREPARE) {\n      setSingleRowHeight(((_a = singleRowRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0);\n    }\n  }, [walkingState]);\n  useIsomorphicLayoutEffect(function () {\n    var _a, _b;\n    if (singleRowHeight) {\n      if (walkingState === PREPARE) {\n        // Ignore if position is enough\n        var midHeight = ((_a = midRowRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0;\n        var maxHeight = rows * singleRowHeight;\n        if (midHeight <= maxHeight) {\n          setWalkingState(DONE_WITHOUT_ELLIPSIS);\n          onEllipsis(false);\n        } else {\n          setWalkingState(WALKING);\n        }\n      } else if (walkingState === WALKING) {\n        if (startLen !== endLen) {\n          var _midHeight = ((_b = midRowRef.current) === null || _b === void 0 ? void 0 : _b.offsetHeight) || 0;\n          var _maxHeight = rows * singleRowHeight;\n          var nextStartLen = startLen;\n          var nextEndLen = endLen;\n          // We reach the last round\n          if (startLen === endLen - 1) {\n            nextEndLen = startLen;\n          } else if (_midHeight <= _maxHeight) {\n            nextStartLen = midLen;\n          } else {\n            nextEndLen = midLen;\n          }\n          var nextMidLen = Math.ceil((nextStartLen + nextEndLen) / 2);\n          setCutLength([nextStartLen, nextMidLen, nextEndLen]);\n        } else {\n          setWalkingState(DONE_WITH_ELLIPSIS);\n          onEllipsis(true);\n        }\n      }\n    }\n  }, [walkingState, startLen, endLen, rows, singleRowHeight]);\n  // ======================= Render =======================\n  var measureStyle = {\n    width: width,\n    whiteSpace: 'normal',\n    margin: 0,\n    padding: 0\n  };\n  var renderMeasure = function renderMeasure(content, ref, style) {\n    return /*#__PURE__*/React.createElement(\"span\", {\n      \"aria-hidden\": true,\n      ref: ref,\n      style: Object.assign({\n        position: 'fixed',\n        display: 'block',\n        left: 0,\n        top: 0,\n        zIndex: -9999,\n        visibility: 'hidden',\n        pointerEvents: 'none',\n        fontSize: Math.floor(fontSize / 2) * 2\n      }, style)\n    }, content);\n  };\n  var renderMeasureSlice = function renderMeasureSlice(len, ref) {\n    var sliceNodeList = sliceNodes(nodeList, len);\n    return renderMeasure(children(sliceNodeList, true), ref, measureStyle);\n  };\n  return /*#__PURE__*/React.createElement(React.Fragment, null, mergedChildren, enabledMeasure && walkingState !== DONE_WITH_ELLIPSIS && walkingState !== DONE_WITHOUT_ELLIPSIS && /*#__PURE__*/React.createElement(React.Fragment, null, renderMeasure('lg', singleRowRef, {\n    wordBreak: 'keep-all',\n    whiteSpace: 'nowrap'\n  }), walkingState === PREPARE ? renderMeasure(children(nodeList, false), midRowRef, measureStyle) : renderMeasureSlice(midLen, midRowRef)));\n};\nif (process.env.NODE_ENV !== 'production') {\n  Ellipsis.displayName = 'Ellipsis';\n}\nexport default Ellipsis;","map":{"version":3,"names":["toArray","useIsomorphicLayoutEffect","React","cuttable","node","type","getNodesLen","nodeList","totalLen","forEach","String","length","sliceNodes","len","currLen","currentNodeList","i","canCut","nodeLen","nextLen","restLen","push","slice","NONE","PREPARE","WALKING","DONE_WITH_ELLIPSIS","DONE_WITHOUT_ELLIPSIS","Ellipsis","_ref","enabledMeasure","children","text","width","fontSize","rows","onEllipsis","_React$useState","useState","_React$useState2","_slicedToArray","_React$useState2$","startLen","midLen","endLen","setCutLength","_React$useState3","_React$useState4","walkingState","setWalkingState","_React$useState5","_React$useState6","singleRowHeight","setSingleRowHeight","singleRowRef","useRef","midRowRef","useMemo","mergedChildren","Math","ceil","_a","current","offsetHeight","_b","midHeight","maxHeight","nextStartLen","nextEndLen","nextMidLen","measureStyle","whiteSpace","margin","padding","renderMeasure","content","ref","style","createElement","Object","assign","position","display","left","top","zIndex","visibility","pointerEvents","floor","renderMeasureSlice","sliceNodeList","Fragment","wordBreak","process","env","NODE_ENV","displayName"],"sources":["C:/Users/parkj/Desktop/OSS/Git_filemanager/frontend/node_modules/antd/es/typography/Base/Ellipsis.js"],"sourcesContent":["import toArray from \"rc-util/es/Children/toArray\";\r\nimport useIsomorphicLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\r\nimport * as React from 'react';\r\nfunction cuttable(node) {\r\n  const type = typeof node;\r\n  return type === 'string' || type === 'number';\r\n}\r\nfunction getNodesLen(nodeList) {\r\n  let totalLen = 0;\r\n  nodeList.forEach(node => {\r\n    if (cuttable(node)) {\r\n      totalLen += String(node).length;\r\n    } else {\r\n      totalLen += 1;\r\n    }\r\n  });\r\n  return totalLen;\r\n}\r\nfunction sliceNodes(nodeList, len) {\r\n  let currLen = 0;\r\n  const currentNodeList = [];\r\n  for (let i = 0; i < nodeList.length; i += 1) {\r\n    // Match to return\r\n    if (currLen === len) {\r\n      return currentNodeList;\r\n    }\r\n    const node = nodeList[i];\r\n    const canCut = cuttable(node);\r\n    const nodeLen = canCut ? String(node).length : 1;\r\n    const nextLen = currLen + nodeLen;\r\n    // Exceed but current not which means we need cut this\r\n    // This will not happen on validate ReactElement\r\n    if (nextLen > len) {\r\n      const restLen = len - currLen;\r\n      currentNodeList.push(String(node).slice(0, restLen));\r\n      return currentNodeList;\r\n    }\r\n    currentNodeList.push(node);\r\n    currLen = nextLen;\r\n  }\r\n  return nodeList;\r\n}\r\nconst NONE = 0;\r\nconst PREPARE = 1;\r\nconst WALKING = 2;\r\nconst DONE_WITH_ELLIPSIS = 3;\r\nconst DONE_WITHOUT_ELLIPSIS = 4;\r\nconst Ellipsis = _ref => {\r\n  let {\r\n    enabledMeasure,\r\n    children,\r\n    text,\r\n    width,\r\n    fontSize,\r\n    rows,\r\n    onEllipsis\r\n  } = _ref;\r\n  const [[startLen, midLen, endLen], setCutLength] = React.useState([0, 0, 0]);\r\n  const [walkingState, setWalkingState] = React.useState(NONE);\r\n  const [singleRowHeight, setSingleRowHeight] = React.useState(0);\r\n  const singleRowRef = React.useRef(null);\r\n  const midRowRef = React.useRef(null);\r\n  const nodeList = React.useMemo(() => toArray(text), [text]);\r\n  const totalLen = React.useMemo(() => getNodesLen(nodeList), [nodeList]);\r\n  const mergedChildren = React.useMemo(() => {\r\n    if (!enabledMeasure || walkingState !== DONE_WITH_ELLIPSIS) {\r\n      return children(nodeList, false);\r\n    }\r\n    return children(sliceNodes(nodeList, midLen), midLen < totalLen);\r\n  }, [enabledMeasure, walkingState, children, nodeList, midLen, totalLen]);\r\n  // ======================== Walk ========================\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (enabledMeasure && width && fontSize && totalLen) {\r\n      setWalkingState(PREPARE);\r\n      setCutLength([0, Math.ceil(totalLen / 2), totalLen]);\r\n    }\r\n  }, [enabledMeasure, width, fontSize, text, totalLen, rows]);\r\n  useIsomorphicLayoutEffect(() => {\r\n    var _a;\r\n    if (walkingState === PREPARE) {\r\n      setSingleRowHeight(((_a = singleRowRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0);\r\n    }\r\n  }, [walkingState]);\r\n  useIsomorphicLayoutEffect(() => {\r\n    var _a, _b;\r\n    if (singleRowHeight) {\r\n      if (walkingState === PREPARE) {\r\n        // Ignore if position is enough\r\n        const midHeight = ((_a = midRowRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0;\r\n        const maxHeight = rows * singleRowHeight;\r\n        if (midHeight <= maxHeight) {\r\n          setWalkingState(DONE_WITHOUT_ELLIPSIS);\r\n          onEllipsis(false);\r\n        } else {\r\n          setWalkingState(WALKING);\r\n        }\r\n      } else if (walkingState === WALKING) {\r\n        if (startLen !== endLen) {\r\n          const midHeight = ((_b = midRowRef.current) === null || _b === void 0 ? void 0 : _b.offsetHeight) || 0;\r\n          const maxHeight = rows * singleRowHeight;\r\n          let nextStartLen = startLen;\r\n          let nextEndLen = endLen;\r\n          // We reach the last round\r\n          if (startLen === endLen - 1) {\r\n            nextEndLen = startLen;\r\n          } else if (midHeight <= maxHeight) {\r\n            nextStartLen = midLen;\r\n          } else {\r\n            nextEndLen = midLen;\r\n          }\r\n          const nextMidLen = Math.ceil((nextStartLen + nextEndLen) / 2);\r\n          setCutLength([nextStartLen, nextMidLen, nextEndLen]);\r\n        } else {\r\n          setWalkingState(DONE_WITH_ELLIPSIS);\r\n          onEllipsis(true);\r\n        }\r\n      }\r\n    }\r\n  }, [walkingState, startLen, endLen, rows, singleRowHeight]);\r\n  // ======================= Render =======================\r\n  const measureStyle = {\r\n    width,\r\n    whiteSpace: 'normal',\r\n    margin: 0,\r\n    padding: 0\r\n  };\r\n  const renderMeasure = (content, ref, style) => /*#__PURE__*/React.createElement(\"span\", {\r\n    \"aria-hidden\": true,\r\n    ref: ref,\r\n    style: Object.assign({\r\n      position: 'fixed',\r\n      display: 'block',\r\n      left: 0,\r\n      top: 0,\r\n      zIndex: -9999,\r\n      visibility: 'hidden',\r\n      pointerEvents: 'none',\r\n      fontSize: Math.floor(fontSize / 2) * 2\r\n    }, style)\r\n  }, content);\r\n  const renderMeasureSlice = (len, ref) => {\r\n    const sliceNodeList = sliceNodes(nodeList, len);\r\n    return renderMeasure(children(sliceNodeList, true), ref, measureStyle);\r\n  };\r\n  return /*#__PURE__*/React.createElement(React.Fragment, null, mergedChildren, enabledMeasure && walkingState !== DONE_WITH_ELLIPSIS && walkingState !== DONE_WITHOUT_ELLIPSIS && /*#__PURE__*/React.createElement(React.Fragment, null, renderMeasure('lg', singleRowRef, {\r\n    wordBreak: 'keep-all',\r\n    whiteSpace: 'nowrap'\r\n  }), walkingState === PREPARE ? renderMeasure(children(nodeList, false), midRowRef, measureStyle) : renderMeasureSlice(midLen, midRowRef)));\r\n};\r\nif (process.env.NODE_ENV !== 'production') {\r\n  Ellipsis.displayName = 'Ellipsis';\r\n}\r\nexport default Ellipsis;"],"mappings":";AAAA,OAAOA,OAAO,MAAM,6BAA6B;AACjD,OAAOC,yBAAyB,MAAM,kCAAkC;AACxE,OAAO,KAAKC,KAAK,MAAM,OAAO;AAC9B,SAASC,QAAQA,CAACC,IAAI,EAAE;EACtB,IAAMC,IAAI,GAAG,OAAOD,IAAI;EACxB,OAAOC,IAAI,KAAK,QAAQ,IAAIA,IAAI,KAAK,QAAQ;AAC/C;AACA,SAASC,WAAWA,CAACC,QAAQ,EAAE;EAC7B,IAAIC,QAAQ,GAAG,CAAC;EAChBD,QAAQ,CAACE,OAAO,CAAC,UAAAL,IAAI,EAAI;IACvB,IAAID,QAAQ,CAACC,IAAI,CAAC,EAAE;MAClBI,QAAQ,IAAIE,MAAM,CAACN,IAAI,CAAC,CAACO,MAAM;IACjC,CAAC,MAAM;MACLH,QAAQ,IAAI,CAAC;IACf;EACF,CAAC,CAAC;EACF,OAAOA,QAAQ;AACjB;AACA,SAASI,UAAUA,CAACL,QAAQ,EAAEM,GAAG,EAAE;EACjC,IAAIC,OAAO,GAAG,CAAC;EACf,IAAMC,eAAe,GAAG,EAAE;EAC1B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,QAAQ,CAACI,MAAM,EAAEK,CAAC,IAAI,CAAC,EAAE;IAC3C;IACA,IAAIF,OAAO,KAAKD,GAAG,EAAE;MACnB,OAAOE,eAAe;IACxB;IACA,IAAMX,IAAI,GAAGG,QAAQ,CAACS,CAAC,CAAC;IACxB,IAAMC,MAAM,GAAGd,QAAQ,CAACC,IAAI,CAAC;IAC7B,IAAMc,OAAO,GAAGD,MAAM,GAAGP,MAAM,CAACN,IAAI,CAAC,CAACO,MAAM,GAAG,CAAC;IAChD,IAAMQ,OAAO,GAAGL,OAAO,GAAGI,OAAO;IACjC;IACA;IACA,IAAIC,OAAO,GAAGN,GAAG,EAAE;MACjB,IAAMO,OAAO,GAAGP,GAAG,GAAGC,OAAO;MAC7BC,eAAe,CAACM,IAAI,CAACX,MAAM,CAACN,IAAI,CAAC,CAACkB,KAAK,CAAC,CAAC,EAAEF,OAAO,CAAC,CAAC;MACpD,OAAOL,eAAe;IACxB;IACAA,eAAe,CAACM,IAAI,CAACjB,IAAI,CAAC;IAC1BU,OAAO,GAAGK,OAAO;EACnB;EACA,OAAOZ,QAAQ;AACjB;AACA,IAAMgB,IAAI,GAAG,CAAC;AACd,IAAMC,OAAO,GAAG,CAAC;AACjB,IAAMC,OAAO,GAAG,CAAC;AACjB,IAAMC,kBAAkB,GAAG,CAAC;AAC5B,IAAMC,qBAAqB,GAAG,CAAC;AAC/B,IAAMC,QAAQ,GAAG,SAAXA,QAAQA,CAAGC,IAAI,EAAI;EACvB,IACEC,cAAc,GAOZD,IAAI,CAPNC,cAAc;IACdC,QAAQ,GAMNF,IAAI,CANNE,QAAQ;IACRC,IAAI,GAKFH,IAAI,CALNG,IAAI;IACJC,KAAK,GAIHJ,IAAI,CAJNI,KAAK;IACLC,QAAQ,GAGNL,IAAI,CAHNK,QAAQ;IACRC,IAAI,GAEFN,IAAI,CAFNM,IAAI;IACJC,UAAU,GACRP,IAAI,CADNO,UAAU;EAEZ,IAAAC,eAAA,GAAmDnC,KAAK,CAACoC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAAAC,gBAAA,GAAAC,cAAA,CAAAH,eAAA;IAAAI,iBAAA,GAAAD,cAAA,CAAAD,gBAAA;IAApEG,QAAQ,GAAAD,iBAAA;IAAEE,MAAM,GAAAF,iBAAA;IAAEG,MAAM,GAAAH,iBAAA;IAAGI,YAAY,GAAAN,gBAAA;EAC/C,IAAAO,gBAAA,GAAwC5C,KAAK,CAACoC,QAAQ,CAACf,IAAI,CAAC;IAAAwB,gBAAA,GAAAP,cAAA,CAAAM,gBAAA;IAArDE,YAAY,GAAAD,gBAAA;IAAEE,eAAe,GAAAF,gBAAA;EACpC,IAAAG,gBAAA,GAA8ChD,KAAK,CAACoC,QAAQ,CAAC,CAAC,CAAC;IAAAa,gBAAA,GAAAX,cAAA,CAAAU,gBAAA;IAAxDE,eAAe,GAAAD,gBAAA;IAAEE,kBAAkB,GAAAF,gBAAA;EAC1C,IAAMG,YAAY,GAAGpD,KAAK,CAACqD,MAAM,CAAC,IAAI,CAAC;EACvC,IAAMC,SAAS,GAAGtD,KAAK,CAACqD,MAAM,CAAC,IAAI,CAAC;EACpC,IAAMhD,QAAQ,GAAGL,KAAK,CAACuD,OAAO,CAAC;IAAA,OAAMzD,OAAO,CAACgC,IAAI,CAAC;EAAA,GAAE,CAACA,IAAI,CAAC,CAAC;EAC3D,IAAMxB,QAAQ,GAAGN,KAAK,CAACuD,OAAO,CAAC;IAAA,OAAMnD,WAAW,CAACC,QAAQ,CAAC;EAAA,GAAE,CAACA,QAAQ,CAAC,CAAC;EACvE,IAAMmD,cAAc,GAAGxD,KAAK,CAACuD,OAAO,CAAC,YAAM;IACzC,IAAI,CAAC3B,cAAc,IAAIkB,YAAY,KAAKtB,kBAAkB,EAAE;MAC1D,OAAOK,QAAQ,CAACxB,QAAQ,EAAE,KAAK,CAAC;IAClC;IACA,OAAOwB,QAAQ,CAACnB,UAAU,CAACL,QAAQ,EAAEoC,MAAM,CAAC,EAAEA,MAAM,GAAGnC,QAAQ,CAAC;EAClE,CAAC,EAAE,CAACsB,cAAc,EAAEkB,YAAY,EAAEjB,QAAQ,EAAExB,QAAQ,EAAEoC,MAAM,EAAEnC,QAAQ,CAAC,CAAC;EACxE;EACAP,yBAAyB,CAAC,YAAM;IAC9B,IAAI6B,cAAc,IAAIG,KAAK,IAAIC,QAAQ,IAAI1B,QAAQ,EAAE;MACnDyC,eAAe,CAACzB,OAAO,CAAC;MACxBqB,YAAY,CAAC,CAAC,CAAC,EAAEc,IAAI,CAACC,IAAI,CAACpD,QAAQ,GAAG,CAAC,CAAC,EAAEA,QAAQ,CAAC,CAAC;IACtD;EACF,CAAC,EAAE,CAACsB,cAAc,EAAEG,KAAK,EAAEC,QAAQ,EAAEF,IAAI,EAAExB,QAAQ,EAAE2B,IAAI,CAAC,CAAC;EAC3DlC,yBAAyB,CAAC,YAAM;IAC9B,IAAI4D,EAAE;IACN,IAAIb,YAAY,KAAKxB,OAAO,EAAE;MAC5B6B,kBAAkB,CAAC,CAAC,CAACQ,EAAE,GAAGP,YAAY,CAACQ,OAAO,MAAM,IAAI,IAAID,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACE,YAAY,KAAK,CAAC,CAAC;IAC7G;EACF,CAAC,EAAE,CAACf,YAAY,CAAC,CAAC;EAClB/C,yBAAyB,CAAC,YAAM;IAC9B,IAAI4D,EAAE,EAAEG,EAAE;IACV,IAAIZ,eAAe,EAAE;MACnB,IAAIJ,YAAY,KAAKxB,OAAO,EAAE;QAC5B;QACA,IAAMyC,SAAS,GAAG,CAAC,CAACJ,EAAE,GAAGL,SAAS,CAACM,OAAO,MAAM,IAAI,IAAID,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACE,YAAY,KAAK,CAAC;QACtG,IAAMG,SAAS,GAAG/B,IAAI,GAAGiB,eAAe;QACxC,IAAIa,SAAS,IAAIC,SAAS,EAAE;UAC1BjB,eAAe,CAACtB,qBAAqB,CAAC;UACtCS,UAAU,CAAC,KAAK,CAAC;QACnB,CAAC,MAAM;UACLa,eAAe,CAACxB,OAAO,CAAC;QAC1B;MACF,CAAC,MAAM,IAAIuB,YAAY,KAAKvB,OAAO,EAAE;QACnC,IAAIiB,QAAQ,KAAKE,MAAM,EAAE;UACvB,IAAMqB,UAAS,GAAG,CAAC,CAACD,EAAE,GAAGR,SAAS,CAACM,OAAO,MAAM,IAAI,IAAIE,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACD,YAAY,KAAK,CAAC;UACtG,IAAMG,UAAS,GAAG/B,IAAI,GAAGiB,eAAe;UACxC,IAAIe,YAAY,GAAGzB,QAAQ;UAC3B,IAAI0B,UAAU,GAAGxB,MAAM;UACvB;UACA,IAAIF,QAAQ,KAAKE,MAAM,GAAG,CAAC,EAAE;YAC3BwB,UAAU,GAAG1B,QAAQ;UACvB,CAAC,MAAM,IAAIuB,UAAS,IAAIC,UAAS,EAAE;YACjCC,YAAY,GAAGxB,MAAM;UACvB,CAAC,MAAM;YACLyB,UAAU,GAAGzB,MAAM;UACrB;UACA,IAAM0B,UAAU,GAAGV,IAAI,CAACC,IAAI,CAAC,CAACO,YAAY,GAAGC,UAAU,IAAI,CAAC,CAAC;UAC7DvB,YAAY,CAAC,CAACsB,YAAY,EAAEE,UAAU,EAAED,UAAU,CAAC,CAAC;QACtD,CAAC,MAAM;UACLnB,eAAe,CAACvB,kBAAkB,CAAC;UACnCU,UAAU,CAAC,IAAI,CAAC;QAClB;MACF;IACF;EACF,CAAC,EAAE,CAACY,YAAY,EAAEN,QAAQ,EAAEE,MAAM,EAAET,IAAI,EAAEiB,eAAe,CAAC,CAAC;EAC3D;EACA,IAAMkB,YAAY,GAAG;IACnBrC,KAAK,EAALA,KAAK;IACLsC,UAAU,EAAE,QAAQ;IACpBC,MAAM,EAAE,CAAC;IACTC,OAAO,EAAE;EACX,CAAC;EACD,IAAMC,aAAa,GAAG,SAAhBA,aAAaA,CAAIC,OAAO,EAAEC,GAAG,EAAEC,KAAK;IAAA,OAAK,aAAa3E,KAAK,CAAC4E,aAAa,CAAC,MAAM,EAAE;MACtF,aAAa,EAAE,IAAI;MACnBF,GAAG,EAAEA,GAAG;MACRC,KAAK,EAAEE,MAAM,CAACC,MAAM,CAAC;QACnBC,QAAQ,EAAE,OAAO;QACjBC,OAAO,EAAE,OAAO;QAChBC,IAAI,EAAE,CAAC;QACPC,GAAG,EAAE,CAAC;QACNC,MAAM,EAAE,CAAC,IAAI;QACbC,UAAU,EAAE,QAAQ;QACpBC,aAAa,EAAE,MAAM;QACrBrD,QAAQ,EAAEyB,IAAI,CAAC6B,KAAK,CAACtD,QAAQ,GAAG,CAAC,CAAC,GAAG;MACvC,CAAC,EAAE2C,KAAK;IACV,CAAC,EAAEF,OAAO,CAAC;EAAA;EACX,IAAMc,kBAAkB,GAAG,SAArBA,kBAAkBA,CAAI5E,GAAG,EAAE+D,GAAG,EAAK;IACvC,IAAMc,aAAa,GAAG9E,UAAU,CAACL,QAAQ,EAAEM,GAAG,CAAC;IAC/C,OAAO6D,aAAa,CAAC3C,QAAQ,CAAC2D,aAAa,EAAE,IAAI,CAAC,EAAEd,GAAG,EAAEN,YAAY,CAAC;EACxE,CAAC;EACD,OAAO,aAAapE,KAAK,CAAC4E,aAAa,CAAC5E,KAAK,CAACyF,QAAQ,EAAE,IAAI,EAAEjC,cAAc,EAAE5B,cAAc,IAAIkB,YAAY,KAAKtB,kBAAkB,IAAIsB,YAAY,KAAKrB,qBAAqB,IAAI,aAAazB,KAAK,CAAC4E,aAAa,CAAC5E,KAAK,CAACyF,QAAQ,EAAE,IAAI,EAAEjB,aAAa,CAAC,IAAI,EAAEpB,YAAY,EAAE;IACxQsC,SAAS,EAAE,UAAU;IACrBrB,UAAU,EAAE;EACd,CAAC,CAAC,EAAEvB,YAAY,KAAKxB,OAAO,GAAGkD,aAAa,CAAC3C,QAAQ,CAACxB,QAAQ,EAAE,KAAK,CAAC,EAAEiD,SAAS,EAAEc,YAAY,CAAC,GAAGmB,kBAAkB,CAAC9C,MAAM,EAAEa,SAAS,CAAC,CAAC,CAAC;AAC5I,CAAC;AACD,IAAIqC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;EACzCnE,QAAQ,CAACoE,WAAW,GAAG,UAAU;AACnC;AACA,eAAepE,QAAQ"},"metadata":{},"sourceType":"module","externalDependencies":[]}